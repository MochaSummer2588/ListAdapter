<!DOCTYPE HTML>
<html lang="it">
<head>
<!-- Generated by javadoc (21) on Sat Jun 14 22:03:07 CEST 2025 -->
<title>TestSubListAdapter</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2025-06-14">
<meta name="description" content="declaration: package: myTest, class: TestSubListAdapter">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li>Field</li>
<li><a href="#constructor-summary">Constr</a></li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li><a href="#constructor-detail">Constr</a></li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">myTest</a></div>
<h1 title="Class TestSubListAdapter" class="title">Class TestSubListAdapter</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">myTest.TestSubListAdapter</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">TestSubListAdapter</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Suite di test per la classe interna <code>myAdapter.ListAdapter.SubList</code>.
 <p>
 Riassunto: Verifica il corretto funzionamento dei metodi della <code>SubList</code>,
 assicurando che agisca come una vista sulla lista padre e che le modifiche
 siano reciprocamente riflesse. Particolare attenzione è data alla gestione
 degli indici e alla propagazione delle operazioni alla lista sottostante.
 <p>
 Design: Utilizza JUnit 4.13.2. Ogni test case opera su una `SubList` creata
 da una `ListAdapter` popolata, che viene ripristinata prima di ogni test.
 Si testa il comportamento della `SubList` sia in condizioni normali che al bordo
 dei suoi limiti, e le interazioni con la lista padre. Sono inclusi test per le eccezioni.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">TestSubListAdapter</a>()</code></div>
<div class="col-last even-row-color">&nbsp;</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#setUp()" class="member-name-link">setUp</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Configura l'ambiente di test prima di ogni metodo di test.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddAllAtIndexNegativeIndex()" class="member-name-link">testAddAllAtIndexNegativeIndex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#addAll(int,myAdapter.HCollection)"><code>HList.addAll(int, HCollection)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddAllAtIndexOutOfBoundsIndex()" class="member-name-link">testAddAllAtIndexOutOfBoundsIndex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#addAll(int,myAdapter.HCollection)"><code>HList.addAll(int, HCollection)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddAllCollection()" class="member-name-link">testAddAllCollection</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#addAll(myAdapter.HCollection)"><code>HCollection.addAll(HCollection)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddAllCollectionAtIndex()" class="member-name-link">testAddAllCollectionAtIndex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#addAll(int,myAdapter.HCollection)"><code>HList.addAll(int, HCollection)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddAllEmptyCollection()" class="member-name-link">testAddAllEmptyCollection</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#addAll(myAdapter.HCollection)"><code>HCollection.addAll(HCollection)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddAllNullCollection()" class="member-name-link">testAddAllNullCollection</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#addAll(myAdapter.HCollection)"><code>HCollection.addAll(HCollection)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddElementAtIndexSubList()" class="member-name-link">testAddElementAtIndexSubList</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#add(int,java.lang.Object)"><code>HList.add(int, Object)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddElementToSubList()" class="member-name-link">testAddElementToSubList</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#add(java.lang.Object)"><code>HCollection.add(Object)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddNegativeIndex()" class="member-name-link">testAddNegativeIndex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#add(int,java.lang.Object)"><code>HList.add(int, Object)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testAddOutOfBoundsIndex()" class="member-name-link">testAddOutOfBoundsIndex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#add(int,java.lang.Object)"><code>HList.add(int, Object)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testClearSubList()" class="member-name-link">testClearSubList</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#clear()"><code>HCollection.clear()</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testContainsAllEmptyCollection()" class="member-name-link">testContainsAllEmptyCollection</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#containsAll(myAdapter.HCollection)"><code>HCollection.containsAll(HCollection)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testContainsAllExisting()" class="member-name-link">testContainsAllExisting</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#containsAll(myAdapter.HCollection)"><code>HCollection.containsAll(HCollection)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testContainsAllNotExisting()" class="member-name-link">testContainsAllNotExisting</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#containsAll(myAdapter.HCollection)"><code>HCollection.containsAll(HCollection)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testContainsAllNullCollection()" class="member-name-link">testContainsAllNullCollection</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#containsAll(myAdapter.HCollection)"><code>HCollection.containsAll(HCollection)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testContainsExistingElement()" class="member-name-link">testContainsExistingElement</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#contains(java.lang.Object)"><code>HCollection.contains(Object)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testContainsNonExistingElement()" class="member-name-link">testContainsNonExistingElement</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#contains(java.lang.Object)"><code>HCollection.contains(Object)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testGetFirstElement()" class="member-name-link">testGetFirstElement</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#get(int)"><code>HList.get(int)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testGetNegativeIndex()" class="member-name-link">testGetNegativeIndex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#get(int)"><code>HList.get(int)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testGetOutOfBoundsIndex()" class="member-name-link">testGetOutOfBoundsIndex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#get(int)"><code>HList.get(int)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testIndexOfExistingElement()" class="member-name-link">testIndexOfExistingElement</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#indexOf(java.lang.Object)"><code>HList.indexOf(Object)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testIndexOfNonExistingElementInSubList()" class="member-name-link">testIndexOfNonExistingElementInSubList</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#indexOf(java.lang.Object)"><code>HList.indexOf(Object)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testIndexOfNullElement()" class="member-name-link">testIndexOfNullElement</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#indexOf(java.lang.Object)"><code>HList.indexOf(Object)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testInitialSubListSize()" class="member-name-link">testInitialSubListSize</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#size()"><code>HCollection.size()</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testIsEmptyFalse()" class="member-name-link">testIsEmptyFalse</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#isEmpty()"><code>HCollection.isEmpty()</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testIsEmptyTrue()" class="member-name-link">testIsEmptyTrue</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#isEmpty()"><code>HCollection.isEmpty()</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testIterator()" class="member-name-link">testIterator</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#iterator()"><code>HCollection.iterator()</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testLastIndexOfExistingElement()" class="member-name-link">testLastIndexOfExistingElement</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#lastIndexOf(java.lang.Object)"><code>HList.lastIndexOf(Object)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testListIterator()" class="member-name-link">testListIterator</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator()"><code>HList.listIterator()</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testListIteratorFromIndexEnd()" class="member-name-link">testListIteratorFromIndexEnd</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testListIteratorFromIndexMid()" class="member-name-link">testListIteratorFromIndexMid</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testListIteratorFromIndexStart()" class="member-name-link">testListIteratorFromIndexStart</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testListIteratorNegativeIndex()" class="member-name-link">testListIteratorNegativeIndex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testListIteratorOutOfBoundsIndex()" class="member-name-link">testListIteratorOutOfBoundsIndex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testParentSetReflectsInSubList()" class="member-name-link">testParentSetReflectsInSubList</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test di interazione: modifica sulla lista padre si riflette nella sottolista.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testParentStructuralModificationReflectsInSubList_Add()" class="member-name-link">testParentStructuralModificationReflectsInSubList_Add</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test di interazione: aggiunta sulla lista padre e "semantica indefinita" della sottolista.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRemoveAllCollection()" class="member-name-link">testRemoveAllCollection</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#removeAll(myAdapter.HCollection)"><code>HCollection.removeAll(HCollection)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRemoveAllNoMatchingElements()" class="member-name-link">testRemoveAllNoMatchingElements</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#removeAll(myAdapter.HCollection)"><code>HCollection.removeAll(HCollection)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRemoveAllNullCollection()" class="member-name-link">testRemoveAllNullCollection</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#removeAll(myAdapter.HCollection)"><code>HCollection.removeAll(HCollection)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRemoveElementByIndex()" class="member-name-link">testRemoveElementByIndex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#remove(int)"><code>HList.remove(int)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRemoveElementByObject()" class="member-name-link">testRemoveElementByObject</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#remove(java.lang.Object)"><code>HCollection.remove(Object)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRemoveNegativeIndex()" class="member-name-link">testRemoveNegativeIndex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#remove(int)"><code>HList.remove(int)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRemoveNonExistingElementByObject()" class="member-name-link">testRemoveNonExistingElementByObject</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#remove(java.lang.Object)"><code>HCollection.remove(Object)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRemoveNullElementByObject()" class="member-name-link">testRemoveNullElementByObject</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#remove(java.lang.Object)"><code>HCollection.remove(Object)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRemoveOutOfBoundsIndex()" class="member-name-link">testRemoveOutOfBoundsIndex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#remove(int)"><code>HList.remove(int)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRetainAllClearSubList()" class="member-name-link">testRetainAllClearSubList</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#retainAll(myAdapter.HCollection)"><code>HCollection.retainAll(HCollection)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRetainAllCollection()" class="member-name-link">testRetainAllCollection</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#retainAll(myAdapter.HCollection)"><code>HCollection.retainAll(HCollection)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRetainAllNoModification()" class="member-name-link">testRetainAllNoModification</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#retainAll(myAdapter.HCollection)"><code>HCollection.retainAll(HCollection)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testRetainAllNullCollection()" class="member-name-link">testRetainAllNullCollection</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#retainAll(myAdapter.HCollection)"><code>HCollection.retainAll(HCollection)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testSetElement()" class="member-name-link">testSetElement</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#set(int,java.lang.Object)"><code>HList.set(int, Object)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testSetNegativeIndex()" class="member-name-link">testSetNegativeIndex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#set(int,java.lang.Object)"><code>HList.set(int, Object)</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testSetOutOfBoundsIndex()" class="member-name-link">testSetOutOfBoundsIndex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#set(int,java.lang.Object)"><code>HList.set(int, Object)</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testSubListFromSubList()" class="member-name-link">testSubListFromSubList</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#subList(int,int)"><code>HList.subList(int, int)</code></a> di una <code>SubList</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testSubListFromSubListFromGreaterThanTo()" class="member-name-link">testSubListFromSubListFromGreaterThanTo</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#subList(int,int)"><code>HList.subList(int, int)</code></a> su una <code>SubList</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testSubListFromSubListNegativeFromIndex()" class="member-name-link">testSubListFromSubListNegativeFromIndex</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#subList(int,int)"><code>HList.subList(int, int)</code></a> su una <code>SubList</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testSubListFromSubListOutOfBoundsToIndex()" class="member-name-link">testSubListFromSubListOutOfBoundsToIndex</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HList.html#subList(int,int)"><code>HList.subList(int, int)</code></a> su una <code>SubList</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testToArray()" class="member-name-link">testToArray</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#toArray()"><code>HCollection.toArray()</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testToArrayNullArray()" class="member-name-link">testToArrayNullArray</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#toArray(java.lang.Object%5B%5D)"><code>HCollection.toArray(Object[])</code></a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testToArrayWithSufficientlyLargeArray()" class="member-name-link">testToArrayWithSufficientlyLargeArray</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#toArray(java.lang.Object%5B%5D)"><code>HCollection.toArray(Object[])</code></a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#testToArrayWithTooSmallArray()" class="member-name-link">testToArrayWithTooSmallArray</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#toArray(java.lang.Object%5B%5D)"><code>HCollection.toArray(Object[])</code></a>.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>TestSubListAdapter</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">TestSubListAdapter</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="setUp()">
<h3>setUp</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">setUp</span>()</div>
<div class="block">Configura l'ambiente di test prima di ogni metodo di test.
 Inizializza una `ListAdapter` popolata e crea una `SubList` su di essa
 per i test. La `SubList` sarà inizialmente [1, 2, 3].
 <p>
 Lista Padre Iniziale: ["zero", "uno", "due", "tre", "quattro", "cinque"]
 SubList Iniziale (indici della parentList da 1 a 4 esclusi): ["uno", "due", "tre"]</div>
</section>
</li>
<li>
<section class="detail" id="testInitialSubListSize()">
<h3>testInitialSubListSize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testInitialSubListSize</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#size()"><code>HCollection.size()</code></a>.
 <p>
 Summary: Il test verifica il metodo <code>size()</code> di una sottolista non vuota.
 <p>
 Test Case Design: Assicurarsi che la `SubList` calcoli correttamente la sua dimensione,
 che dovrebbe corrispondere al numero di elementi tra `fromIndex` e `toIndex` (escluso `toIndex`).
 <p>
 Test Description: Verifica che la sottolista, creata dagli indici [1, 4) della lista padre,
 abbia una dimensione pari a 3 (4 - 1 = 3) chiamando il metodo <code>size()</code>.
 <p>
 Preconditions: La sottolista è inizializzata per contenere i 3 elementi della lista padre,
 ovvero ["uno", "due", "tre"].
 <p>
 Postconditions: La sottolista rimane invariata.
 <p>
 Expected Result: <code>size()</code> deve restituire 3.</div>
</section>
</li>
<li>
<section class="detail" id="testIsEmptyFalse()">
<h3>testIsEmptyFalse</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testIsEmptyFalse</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#isEmpty()"><code>HCollection.isEmpty()</code></a>.
 <p>
 Summary: Il test verifica il metodo <code>isEmpty()</code> di una sottolista non vuota.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che `isEmpty()` rifletta correttamente
 lo stato di non-vuoto della sottolista, restituendo `false` quando contiene elementi.
 <p>
 Test Description: Verifica che la sottolista, che contiene gli elementi ["uno", "due", "tre"],
 restituisca `false` quando viene chiamato il metodo <code>isEmpty()</code>.
 <p>
 Preconditions: La sottolista è inizializzata con 3 elementi, ovvero ["uno", "due", "tre"].
 <p>
 Postconditions: La sottolista rimane invariata.
 <p>
 Expected Result: <code>isEmpty()</code> deve restituire false.</div>
</section>
</li>
<li>
<section class="detail" id="testIsEmptyTrue()">
<h3>testIsEmptyTrue</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testIsEmptyTrue</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#isEmpty()"><code>HCollection.isEmpty()</code></a>.
 <p>
 Sumary: Verifica che una sottolista creata vuota o svuotata sia correttamente considerata vuota.
 <p>
 Test Case Design: La motivazione dietro a questo test e' assicurarsi che `isEmpty()` restituisca true quando 
 la sottolista non contiene elementi.
 <p>
 Test Description: Viene creata una sottolista vuota (dimensione nulla) tramite la chiamata del metodo subList(1,1) 
 e si verifica che `isEmpty()` restituisca true.
 Successivamente si svuota la sottolista esistente e si verifica nuovamente `isEmpty()`.
 <p>
 Preconditions: Una sottolista esistente con 3 elementi ossia ["uno", "due", "tre"] e un altra sottolista vuota creata con subList(1,1).
 <p>
 Postconditions: Sia la sottolista vuota che quella esistente sono considerate vuote.
 <p>
 Expected Result: <code>isEmpty()</code> deve restituire true da entrambi .</div>
</section>
</li>
<li>
<section class="detail" id="testGetFirstElement()">
<h3>testGetFirstElement</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testGetFirstElement</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#get(int)"><code>HList.get(int)</code></a>.
 <p>
 Summary: Verifica il recupero di un elemento all'inizio della sottolista.
 <p>
 Test Case Design: Il motivo dietro a questo test e' garantire che il metodo `get(int index)` recuperi l'elemento iniziale della sottolista 
 <p>
 Test Description: Verifica che il primo elemento della sottolista sia "uno" (indice 0).
 <p>
 Preconditions: La sottolista contiene ["uno", "due", "tre"].
 <p>
 Postconditions: La sottolista contiene ancora gli stessi elementi.
 <p>
 Expected Result: <code>get(0)</code> deve restituire "uno".</div>
</section>
</li>
<li>
<section class="detail" id="testGetNegativeIndex()">
<h3>testGetNegativeIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testGetNegativeIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#get(int)"><code>HList.get(int)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>get(int index)</code> lanci <code>IndexOutOfBoundsException</code>
 quando si tenta di recuperare un elemento specificando un indice negativo.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità
 alla specifica della Javadoc di `java.util.List.get()`, che impone il lancio di una
 `IndexOutOfBoundsException` per qualsiasi indice che non sia compreso tra 0 (incluso) e `size()` (escluso).
 Questo caso specifico si concentra sulla violazione del limite inferiore dell'indice.
 <p>
 Test Description: 1) Si tenta di accedere a un elemento della sottolista tramite il metodo `get()`.
                   2) Viene fornito un indice intenzionalmente negativo (`-1`).
                   3) Il test si aspetta che, come risultato di questa operazione, venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene:
 ["uno", "due", "tre"].
 <p>
 Postconditions: La sottolista rimane completamente invariata, poiché l'operazione di recupero
 non è stata completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>IndexOutOfBoundsException</code> deve essere lanciata quando si chiama `get(-1)`.</div>
</section>
</li>
<li>
<section class="detail" id="testGetOutOfBoundsIndex()">
<h3>testGetOutOfBoundsIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testGetOutOfBoundsIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#get(int)"><code>HList.get(int)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>get(int index)</code> lanci <code>IndexOutOfBoundsException</code>
 quando si tenta di recuperare un elemento specificando un indice che è fuori dai limiti validi
 della sottolista (ovvero, maggiore o uguale alla dimensione della sottolista).
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità
  di <code>get(int index)</code> che impone il lancio di una
 `IndexOutOfBoundsException` per qualsiasi indice non valido. Questo caso specifico si concentra
 sulla violazione del limite superiore dell'indice.
 <p>
 Test Description: 1) Si tenta di accedere a un elemento della sottolista tramite il metodo `get()`.
                   2) Viene fornito un indice intenzionalmente fuori limite, pari alla dimensione corrente della sottolista (`3`).
                   3) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"],
 pertanto la sua dimensione è 3.
 <p>
 Postconditions: La sottolista rimane completamente invariata, poiché l'operazione di recupero
 non è stata completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>IndexOutOfBoundsException</code> deve essere lanciata quando si chiama `get(3)`.</div>
</section>
</li>
<li>
<section class="detail" id="testIndexOfExistingElement()">
<h3>testIndexOfExistingElement</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testIndexOfExistingElement</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#indexOf(java.lang.Object)"><code>HList.indexOf(Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>indexOf(Object o)</code> restituisca correttamente
 la posizione (indice) della prima occorrenza di un elemento esistente all'interno della sottolista.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che `indexOf()` calcoli
 l'indice relativo corretto di un elemento che è presente nella vista della sottolista.
 <p>
 Test Description: 1) Si cerca l'elemento "due" all'interno della sottolista.
                   2) La sottolista è stata creata con elementi che la rendono una vista valida
                      della lista padre, mantenendo gli indici relativi.
                   3) Il test si aspetta che l'indice restituito sia 1, poiché "due" è il secondo elemento
 nella sequenza della sottolista (["uno", "due", "tre"]).
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 <p>
 Postconditions: La sottolista rimane invariata; l'operazione di ricerca non modifica lo stato della lista.
 <p>
 Expected Result: <code>indexOf("due")</code> deve restituire 1.</div>
</section>
</li>
<li>
<section class="detail" id="testIndexOfNonExistingElementInSubList()">
<h3>testIndexOfNonExistingElementInSubList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testIndexOfNonExistingElementInSubList</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#indexOf(java.lang.Object)"><code>HList.indexOf(Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>indexOf(Object o)</code> restituisca -1
 quando l'elemento cercato non è presente all'interno della vista definita dalla sottolista,
 anche se tale elemento potrebbe esistere nella lista padre al di fuori del range della sottolista.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che la logica di `indexOf()`
 sia correttamente implementata per operare esclusivamente sulla porzione di lista visibile alla sottolista,
 senza "vedere" elementi al di fuori dei suoi indici `fromIndex` e `toIndex`.
 <p>
 Test Description: 1) Si tenta di cercare l'elemento "quattro" all'interno della `subList`.
                   2) La `subList` è stata creata per contenere gli elementi ["uno", "due", "tre"].
                   3) L'elemento "quattro" è presente nella lista padre, ma ad un indice (es. 4) che ricade
                      al di fuori del range della `subList`.
                   4) Il test si aspetta che `indexOf("quattro")` restituisca `-1`, indicando che l'elemento
                  non è stato trovato *all'interno della sottolista*.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La lista padre dalla quale è derivata la sottolista contiene l'elemento "quattro" in una posizione
 non inclusa nel range della sottolista (es. `parentList.get(4)` restituisce "quattro").
 <p>
 Postconditions: La sottolista e la lista padre rimangono invariate; l'operazione di ricerca
 non modifica il loro stato.
 <p>
 Expected Result: <code>indexOf("quattro")</code> deve restituire -1.</div>
</section>
</li>
<li>
<section class="detail" id="testIndexOfNullElement()">
<h3>testIndexOfNullElement</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testIndexOfNullElement</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#indexOf(java.lang.Object)"><code>HList.indexOf(Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>indexOf(Object o)</code> sia in grado di trovare
 correttamente la posizione (indice) della prima occorrenza di un elemento `null` all'interno della sottolista.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che l'implementazione di `indexOf()`
 gestisca correttamente la ricerca di valori `null`.
 <p>
 Test Description: 1) Un elemento `null` viene inserito nella `subList` ad una posizione specifica (indice 1).
                      La sottolista diventa ["uno", `null`, "due", "tre"].
                   2) Si invoca il metodo `indexOf(null)` sulla sottolista modificata.
                   3) Il test si aspetta che l'indice restituito sia 1, corrispondente alla posizione dove è stato inserito il `null`.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 Un elemento `null` viene aggiunto alla sottolista prima della chiamata a `indexOf()`.
 <p>
 Postconditions: L'indice del primo elemento `null` nella sottolista è stato trovato correttamente.
 La sottolista contiene ora un elemento `null` alla posizione 1.
 <p>
 Expected Result: <code>indexOf(null)</code> deve restituire 1.</div>
</section>
</li>
<li>
<section class="detail" id="testLastIndexOfExistingElement()">
<h3>testLastIndexOfExistingElement</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testLastIndexOfExistingElement</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#lastIndexOf(java.lang.Object)"><code>HList.lastIndexOf(Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>lastIndexOf(Object o)</code> restituisca correttamente l'indice dell'ultima occorrenza
 dell'elemento specificato all'interno della sottolista. Questo test si concentra sul caso in cui l'elemento è presente più volte.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che <code>lastIndexOf()</code> gestisca correttamente gli elementi
 duplicati e non si fermi alla prima occorrenza, ma trovi effettivamente l'ultima posizione dell'elemento nella sottolista.
 Questo test convalida tale comportamento.
 <p>
 Test Description: 1) Si modifica la `subList` aggiungendo l'elemento "uno" alla fine, in modo che contenga
                      due occorrenze di "uno" (es. `["uno", "due", "tre", "uno"]`).
                   2) Si invoca il metodo <code>lastIndexOf("uno")</code> sulla `subList` modificata.
                   3) Il test si aspetta che l'indice restituito sia <code>3</code>, che corrisponde alla posizione dell'ultima
                      occorrenza di "uno" nella sottolista.
 <p>
 Preconditions: Una <code>HList</code> (sottolista) è inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 L'elemento "uno" viene aggiunto alla fine della sottolista prima della chiamata a <code>lastIndexOf()</code>,
 rendendola `["uno", "due", "tre", "uno"]`.
 <p>
 Postconditions: Lo stato della `subList` rimane invariato dopo l'esecuzione del test, poiché <code>lastIndexOf()</code>
 è un'operazione di query e non modifica la lista.
 <p>
 Expected Result: La chiamata a <code>subList.lastIndexOf("uno")</code> deve restituire <code>3</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testContainsExistingElement()">
<h3>testContainsExistingElement</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testContainsExistingElement</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#contains(java.lang.Object)"><code>HCollection.contains(Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>contains(Object o)</code> restituisca <code>true</code>
 quando l'elemento specificato è presente all'interno della vista definita dalla sottolista.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che <code>contains()</code>
 sia correttamente implementato per cercare l'elemento solo ed esclusivamente
 all'interno del proprio range di indici (`fromIndex` e `toIndex`), delegando
 la ricerca in modo efficace alla lista padre ma rispettando i propri confini.
 <p>
 Test Description: 1) Si invoca il metodo <code>contains()</code> sulla `subList`, passando come argomento
                      un elemento ("due") che è noto essere presente all'interno del range di elementi della sottolista.
                   2) La sottolista è stata inizializzata con gli elementi ["uno", "due", "tre"].
                   3) Il test si aspetta che <code>contains("due")</code> restituisca <code>true</code>, confermando
                      la corretta rilevazione dell'elemento presente.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 <p>
 Postconditions: La sottolista rimane invariata; l'operazione di ricerca non modifica lo stato della lista.
 <p>
 Expected Result: <code>contains("due")</code> deve restituire <code>true</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testContainsNonExistingElement()">
<h3>testContainsNonExistingElement</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testContainsNonExistingElement</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#contains(java.lang.Object)"><code>HCollection.contains(Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>contains(Object o)</code> restituisca <code>false</code>
 quando l'elemento specificato non è presente all'interno della vista definita dalla sottolista.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che <code>contains()</code>
 non produca "falsi positivi" e che sia in grado di determinare correttamente l'assenza di un elemento,
 sia che l'elemento non esista affatto nella lista padre, sia che esista ma fuori dal range della sottolista.
 <p>
 Test Description: 1) Si invoca il metodo <code>contains()</code> sulla `subList`, passando come argomento
                      un elemento ("sette") che è noto non essere presente all'interno del range di elementi della sottolista,
                      né nella lista padre.
                   2) La sottolista è stata inizializzata con gli elementi ["uno", "due", "tre"].
                   3) Il test si aspetta che <code>contains("sette")</code> restituisca <code>false</code>, confermando
                      la corretta rilevazione dell'assenza dell'elemento.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 L'elemento "sette" non è presente né nella sottolista né nella lista padre.
 <p>
 Postconditions: La sottolista rimane invariata; l'operazione di ricerca non modifica lo stato della lista.
 <p>
 Expected Result: <code>contains("sette")</code> deve restituire <code>false</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testContainsAllExisting()">
<h3>testContainsAllExisting</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testContainsAllExisting</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#containsAll(myAdapter.HCollection)"><code>HCollection.containsAll(HCollection)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>containsAll(HCollection c)</code> restituisca <code>true</code>
 quando tutti gli elementi della collezione specificata sono presenti all'interno della sottolista.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che <code>containsAll()</code>
 sia correttamente implementato per iterare sugli elementi della collezione fornita e verificare
 la loro presenza individuale all'interno della vista della sottolista. Questo convalida che
 la sottolista riconosca un sottoinsieme di elementi che possiede.
 <p>
 Test Description: 1) Viene creata una nuova collezione (`otherCollection`) e popolata con
                      elementi ("uno", "tre") che sono noti essere presenti nella `subList`.
                   2) Si invoca il metodo <code>containsAll()</code> sulla `subList`, passando `otherCollection` come argomento.
                   3) Il test si aspetta che <code>containsAll(otherCollection)</code> restituisca <code>true</code>,
                      confermando che tutti gli elementi di `otherCollection` sono effettivamente contenuti nella `subList`.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La `otherCollection` viene creata e contiene gli elementi ["uno", "tre"].
 <p>
 Postconditions: La sottolista e la `otherCollection` rimangono invariate; l'operazione di query
 non modifica il loro stato.
 <p>
 Expected Result: <code>containsAll</code> deve restituire <code>true</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testContainsAllNotExisting()">
<h3>testContainsAllNotExisting</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testContainsAllNotExisting</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#containsAll(myAdapter.HCollection)"><code>HCollection.containsAll(HCollection)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>containsAll(HCollection c)</code> restituisca <code>false</code>
 quando almeno un elemento della collezione specificata non è presente all'interno della sottolista.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che <code>containsAll()</code>
 funzioni correttamente anche in presenza di elementi non contenuti nella sottolista.
 Si verifica che l'operazione restituisca <code>false</code> non appena trova un singolo elemento
 della collezione fornita che non è presente nella sottolista, in conformità con la logica
 del "tutti gli elementi".
 <p>
 Test Description: 1) Viene creata una nuova collezione (`otherCollection`) e popolata con
                      elementi ("uno", "sette"), dove "uno" è presente nella `subList` ma "sette" non lo è.
                   2) Si invoca il metodo <code>containsAll()</code> sulla `subList`, passando `otherCollection` come argomento.
                   3) Il test si aspetta che <code>containsAll(otherCollection)</code> restituisca <code>false</code>,
                      poiché "sette" non è un elemento della `subList`.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La `otherCollection` viene creata e contiene gli elementi ["uno", "sette"].
 <p>
 Postconditions: La sottolista e la `otherCollection` rimangono invariate; l'operazione di query
 non modifica il loro stato.
 <p>
 Expected Result: <code>containsAll</code> deve restituire <code>false</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testContainsAllEmptyCollection()">
<h3>testContainsAllEmptyCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testContainsAllEmptyCollection</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#containsAll(myAdapter.HCollection)"><code>HCollection.containsAll(HCollection)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>containsAll(HCollection c)</code> restituisca <code>true</code>
 quando la collezione specificata come argomento è vuota, indipendentemente dal contenuto della sottolista.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che <code>containsAll()</code>
 gestisca correttamente il caso limite di una collezione vuota. Per definizione,
 una collezione (o lista) contiene "tutti" gli elementi di una collezione vuota,
 quindi il risultato atteso è sempre <code>true</code>.
 <p>
 Test Description: 1) Viene creata una nuova collezione (`emptyCollection`) che non contiene alcun elemento.
                   2) Si invoca il metodo <code>containsAll()</code> sulla `subList` (che contiene ["uno", "due", "tre"]),
                      passando `emptyCollection` come argomento.
                   3) Il test si aspetta che <code>containsAll(emptyCollection)</code> restituisca <code>true</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La `emptyCollection` viene creata e rimane vuota.
 <p>
 Postconditions: La sottolista e la `emptyCollection` rimangono invariate; l'operazione di query
 non modifica il loro stato.
 <p>
 Expected Result: <code>containsAll(emptyCollection)</code> deve restituire <code>true</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testContainsAllNullCollection()">
<h3>testContainsAllNullCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testContainsAllNullCollection</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#containsAll(myAdapter.HCollection)"><code>HCollection.containsAll(HCollection)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>containsAll(HCollection c)</code> lanci
 una <code>NullPointerException</code> quando la collezione specificata come argomento è `null`.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità
 alla specifica di containsAll(), che impone il lancio di una
 <code>NullPointerException</code> se la collezione fornita è un riferimento `null`. Questo test
 convalida il comportamento atteso per un input non valido.
 <p>
 Test Description: 1) Si invoca il metodo <code>containsAll()</code> sulla `subList`.
                   2) Viene passato `null` come argomento per la collezione.
                   3) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>NullPointerException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 L'argomento passato a <code>containsAll()</code> è `null`.
 <p>
 Postconditions: La sottolista rimane invariata, poiché l'operazione non è completata con successo
 a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>NullPointerException</code> deve essere lanciata quando si chiama <code>containsAll(null)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testAddElementToSubList()">
<h3>testAddElementToSubList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddElementToSubList</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#add(java.lang.Object)"><code>HCollection.add(Object)</code></a>.
 <p>
 Summary: Il test verifica l'aggiunta di un elemento alla fine della sottolista,
 assicurando che tale operazione si rifletta correttamente sia sulla dimensione della sottolista
 che sulla struttura e il contenuto della lista padre sottostante.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che <code>add(Object o)</code>
 sulla sottolista non solo aggiunga l'elemento alla fine della vista della sottolista,
 ma che deleghi correttamente l'inserimento alla lista padre nella posizione corrispondente,
 spostando di conseguenza gli elementi successivi nella lista padre e aggiornando la dimensione della sottolista.
 <p>
 Test Description: 1) Si verifica la dimensione iniziale della `subList` (attesa: 3).
                   2) Viene aggiunto un nuovo elemento ("nuovo") alla `subList` tramite il metodo <code>add()</code>.
                   3) Si verifica che il metodo <code>add()</code> restituisca <code>true</code>.
                   4) Si verifica che la dimensione della `subList` sia aumentata correttamente (attesa: 4).
                   5) Si assicura che l'elemento appena aggiunto sia effettivamente presente alla fine della `subList`
                      (indice 3 della `subList`).
                   6) Si verifica che l'elemento sia stato inserito nella posizione corretta all'interno della `parentList`
                      (indice 4 della `parentList`, che corrisponde all'offset iniziale della `subList` più la sua nuova dimensione).
                   7) Si verifica che gli elementi originali della `parentList` che seguivano la `subList` siano stati
                      correttamente spostati in avanti (ad esempio, "quattro" si trova ora all'indice 5 della `parentList`).
 <p>
 Preconditions: La sottolista è inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La lista padre è inizializzata e contiene gli elementi ["zero", "uno", "due", "tre", "quattro", "cinque"].
 <p>
 Postconditions: La sottolista è modificata e ora contiene gli elementi ["uno", "due", "tre", "nuovo"].
 La lista padre è modificata e ora contiene gli elementi ["zero", "uno", "due", "tre", "nuovo", "quattro", "cinque"].
 La dimensione della sottolista è aumentata di uno.
 <p>
 Expected Result: <code>add("nuovo")</code> deve restituire <code>true</code>.
 La dimensione della sottolista deve essere <code>4</code>.
 L'elemento "nuovo" deve essere all'indice <code>3</code> della sottolista e all'indice <code>4</code> della lista padre.
 L'elemento "quattro" deve essere all'indice <code>5</code> della lista padre.</div>
</section>
</li>
<li>
<section class="detail" id="testAddElementAtIndexSubList()">
<h3>testAddElementAtIndexSubList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddElementAtIndexSubList</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#add(int,java.lang.Object)"><code>HList.add(int, Object)</code></a>.
 <p>
 Summary: Il test verifica l'aggiunta di un elemento in una posizione specifica (indice) all'interno della sottolista,
 assicurando che tale operazione sposti correttamente gli elementi esistenti e mantenga la coerenza
 tra la sottolista e la lista padre sottostante.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che <code>add(int index, Object element)</code>
 sulla sottolista funzioni come previsto per gli inserimenti in posizioni intermedie.
 Ciò implica che l'elemento venga inserito all'indice specificato della sottolista,
 che gli elementi successivi nella sottolista (e di conseguenza nella lista padre) vengano spostati in avanti,
 e che la dimensione della sottolista si aggiorni correttamente.
 <p>
 Test Description: 1) Si verifica la dimensione iniziale della `subList` (attesa: 3).
                   2) Viene aggiunto un nuovo elemento ("inserito") alla `subList` tramite il metodo <code>add(1, "inserito")</code>,
                      inserendolo all'indice 1 della `subList`.
                   3) Si verifica che la dimensione della `subList` sia aumentata correttamente (attesa: 4).
                   4) Si assicura che gli elementi della `subList` siano ora nell'ordine corretto: "uno" all'indice 0,
                      "inserito" all'indice 1, "due" all'indice 2 e "tre" all'indice 3.
                   5) Si verifica anche che l'inserimento si sia propagato correttamente alla `parentList`,
                      controllando le posizioni degli elementi corrispondenti agli indici della `subList` e quelli successivi.
 <p>
 Preconditions: La sottolista è inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La lista padre è inizializzata e contiene gli elementi ["zero", "uno", "due", "tre", "quattro", "cinque"].
 <p>
 Postconditions: La sottolista è modificata e ora contiene gli elementi ["uno", "inserito", "due", "tre"].
 La lista padre è aggiornata di conseguenza, con l'elemento "inserito" nella posizione corretta
 e gli elementi successivi spostati.
 La dimensione della sottolista è aumentata di uno.
 <p>
 Expected Result: L'elemento "inserito" deve essere aggiunto correttamente alla posizione specificata.
 La dimensione della sottolista deve essere aggiornata a 4.
 Tutti gli elementi devono mantenere le loro posizioni relative corrette sia nella sottolista che nella lista padre.</div>
</section>
</li>
<li>
<section class="detail" id="testAddNegativeIndex()">
<h3>testAddNegativeIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddNegativeIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#add(int,java.lang.Object)"><code>HList.add(int, Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>add(int index, Object element)</code> lanci
 una <code>IndexOutOfBoundsException</code> quando si tenta di aggiungere un elemento
 specificando un indice negativo.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità di add(int, Object), che impone il lancio di una
 <code>IndexOutOfBoundsException</code> per qualsiasi indice che non sia compreso tra 0 (incluso) e `size()` (incluso).
 Questo caso specifico si concentra sulla violazione del limite inferiore dell'indice.
 <p>
 Test Description: 1) Si tenta di aggiungere un nuovo elemento ("test") alla `subList`
                      tramite il metodo <code>add(int, Object)</code>.
                   2) Viene fornito un indice intenzionalmente negativo (`-1`).
                   3) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene elementi (ad esempio, ["uno", "due", "tre"]).
 <p>
 Postconditions: La sottolista rimane invariata, poiché l'operazione di aggiunta non è stata
 completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>IndexOutOfBoundsException</code> deve essere lanciata quando si chiama <code>add(-1, "test")</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testAddOutOfBoundsIndex()">
<h3>testAddOutOfBoundsIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddOutOfBoundsIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#add(int,java.lang.Object)"><code>HList.add(int, Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>add(int index, Object element)</code> lanci
 una <code>IndexOutOfBoundsException</code> quando si tenta di aggiungere un elemento
 specificando un indice che è al di fuori dei limiti validi (ovvero, maggiore della sua dimensione).
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità di add(int, Object)`, che impone il lancio di una
 <code>IndexOutOfBoundsException</code> per qualsiasi indice che non sia compreso tra 0 (incluso) e `size()` (incluso).
 Questo caso specifico si concentra sulla violazione del limite superiore dell'indice.
 <p>
 Test Description: 1) Si tenta di aggiungere un nuovo elemento ("test") alla `subList`
                      tramite il metodo <code>add(int, Object)</code>.
                   2) Viene fornito un indice intenzionalmente fuori limite, pari a <code>4</code>, mentre la dimensione
                      della sottolista è <code>3</code> (gli indici validi per l'aggiunta sono da <code>0</code> a <code>3</code>).
                   3) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene 3 elementi (ad esempio, ["uno", "due", "tre"]).
 <p>
 Postconditions: La sottolista rimane invariata, poiché l'operazione di aggiunta non è stata
 completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>IndexOutOfBoundsException</code> deve essere lanciata quando si chiama <code>add(4, "test")</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testRemoveElementByIndex()">
<h3>testRemoveElementByIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRemoveElementByIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#remove(int)"><code>HList.remove(int)</code></a>.
 <p>
 Summary: Il test verifica la rimozione di un elemento in una posizione specifica (indice) dalla sottolista,
 assicurando che tale operazione si rifletta correttamente sia sulla dimensione della sottolista
 che sulla struttura e il contenuto della lista padre sottostante.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che <code>remove(int index)</code>
 sulla sottolista non solo rimuova l'elemento dalla vista della sottolista,
 ma che deleghi correttamente la rimozione alla lista padre nella posizione corrispondente,
 spostando di conseguenza gli elementi successivi nella lista padre e aggiornando la dimensione della sottolista.
 <p>
 Test Description: 1) Si verifica la dimensione iniziale della `subList` (attesa: 3).
                   2) Viene rimosso un elemento dalla `subList` tramite il metodo <code>remove(1)</code>,
                      rimuovendo l'elemento all'indice 1 della `subList` (che è "due").
                   3) Si verifica che il metodo <code>remove()</code> restituisca l'elemento corretto ("due").
                   4) Si verifica che la dimensione della `subList` sia diminuita correttamente (attesa: 2).
                   5) Si assicura che gli elementi rimanenti nella `subList` siano ora nell'ordine corretto:
                      "uno" all'indice 0 e "tre" all'indice 1.
                   6) Si verifica anche che la rimozione si sia propagata correttamente alla `parentList`,
                      controllando le posizioni degli elementi che erano presenti e lo spostamento di quelli successivi.
 <p>
 Preconditions: La sottolista è inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La lista padre è inizializzata e contiene gli elementi ["zero", "uno", "due", "tre", "quattro", "cinque"].
 <p>
 Postconditions: La sottolista è modificata e ora contiene gli elementi ["uno", "tre"].
 La lista padre è aggiornata di conseguenza, con l'elemento rimosso e gli elementi successivi spostati indietro.
 La dimensione della sottolista è diminuita di uno.
 <p>
 Expected Result: L'elemento "due" deve essere rimosso correttamente.
 La dimensione della sottolista deve essere aggiornata a 2.
 Gli elementi rimanenti devono mantenere le loro posizioni relative corrette sia nella sottolista che nella lista padre.</div>
</section>
</li>
<li>
<section class="detail" id="testRemoveNegativeIndex()">
<h3>testRemoveNegativeIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRemoveNegativeIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#remove(int)"><code>HList.remove(int)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>remove(int index)</code> lanci
 una <code>IndexOutOfBoundsException</code> quando si tenta di rimuovere un elemento
 specificando un indice negativo.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità
 alla specifica di remove(int), che impone il lancio di una
 <code>IndexOutOfBoundsException</code> per qualsiasi indice non compreso tra 0 (incluso) e `size()` (escluso).
 Questo caso specifico si concentra sulla violazione del limite inferiore dell'indice.
 <p>
 Test Description: 1) Si tenta di rimuovere un elemento dalla `subList`
                      tramite il metodo <code>remove(int)</code>.
                   2) Viene fornito un indice intenzionalmente negativo (`-1`).
                   3) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene elementi (ad esempio, ["uno", "due", "tre"]).
 <p>
 Postconditions: La sottolista rimane invariata, poiché l'operazione di rimozione non è stata
 completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>IndexOutOfBoundsException</code> deve essere lanciata quando si chiama <code>remove(-1)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testRemoveOutOfBoundsIndex()">
<h3>testRemoveOutOfBoundsIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRemoveOutOfBoundsIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#remove(int)"><code>HList.remove(int)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>remove(int index)</code> lanci
 una <code>IndexOutOfBoundsException</code> quando si tenta di rimuovere un elemento
 specificando un indice che è al di fuori dei limiti validi (ovvero, maggiore o uguale alla dimensione).
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità
 alla specifica di remove(int), che impone il lancio di una
 <code>IndexOutOfBoundsException</code> per qualsiasi indice non compreso tra 0 (incluso) e `size()` (escluso).
 Questo caso specifico si concentra sulla violazione del limite superiore dell'indice.
 <p>
 Test Description: 1) Si tenta di rimuovere un elemento dalla `subList`
                      tramite il metodo <code>remove(int)</code>.
                   2) Viene fornito un indice intenzionalmente fuori limite, pari a <code>3</code>,
                      mentre la dimensione della sottolista è <code>3</code> (gli indici validi sono da <code>0</code> a <code>2</code>).
                   3) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene 3 elementi (ad esempio, ["uno", "due", "tre"]).
 <p>
 Postconditions: La sottolista rimane invariata, poiché l'operazione di rimozione non è stata
 completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>IndexOutOfBoundsException</code> deve essere lanciata quando si chiama <code>remove(3)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testRemoveElementByObject()">
<h3>testRemoveElementByObject</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRemoveElementByObject</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#remove(java.lang.Object)"><code>HCollection.remove(Object)</code></a>.
 <p>
 Summary: Il test verifica la rimozione della prima occorrenza di un elemento specifico
 dalla sottolista, assicurando che l'operazione sia correttamente riflessa
 sia nella dimensione e nel contenuto della sottolista che nella lista padre sottostante.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che <code>remove(Object o)</code>
 sulla sottolista trovi e rimuova correttamente la prima occorrenza dell'elemento specificato
 all'interno del proprio range. Si vuole anche assicurare che tale rimozione
 si propaghi correttamente alla lista padre, causando lo spostamento degli elementi successivi
 e l'aggiornamento della dimensione della sottolista.
 <p>
 Test Description: 1) Si verifica la dimensione iniziale della `subList` (attesa: 3).
                   2) Si tenta di rimuovere l'elemento "due" dalla `subList` tramite il metodo <code>remove(Object)</code>.
                   3) Si verifica che il metodo <code>remove()</code> restituisca <code>true</code>, indicando che l'elemento è stato rimosso.
                   4) Si verifica che la dimensione della `subList` sia diminuita correttamente (attesa: 2).
                   5) Si assicura che gli elementi rimanenti nella `subList` siano ora nell'ordine corretto:
                      "uno" all'indice 0 e "tre" all'indice 1.
                   6) Si verifica anche che la rimozione si sia propagata correttamente alla `parentList`,
                      controllando le posizioni degli elementi e lo spostamento di quelli successivi.
 <p>
 Preconditions: La sottolista è inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La lista padre è inizializzata e contiene gli elementi ["zero", "uno", "due", "tre", "quattro", "cinque"].
 <p>
 Postconditions: La sottolista è modificata e ora contiene gli elementi ["uno", "tre"].
 La lista padre è aggiornata di conseguenza, con l'elemento rimosso e gli elementi successivi spostati indietro.
 La dimensione della sottolista è diminuita di uno.
 <p>
 Expected Result: <code>remove("due")</code> deve restituire <code>true</code>.
 La dimensione della sottolista deve essere <code>2</code>.
 Gli elementi "uno" e "tre" devono essere rispettivamente agli indici <code>0</code> e <code>1</code> della sottolista.
 La lista padre deve riflettere la rimozione di "due".</div>
</section>
</li>
<li>
<section class="detail" id="testRemoveNonExistingElementByObject()">
<h3>testRemoveNonExistingElementByObject</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRemoveNonExistingElementByObject</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#remove(java.lang.Object)"><code>HCollection.remove(Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>remove(Object o)</code> non modifichi
 la sottolista (e di conseguenza la lista padre) e restituisca <code>false</code>
 quando si tenta di rimuovere un elemento che non è presente nella sottolista.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che <code>remove(Object o)</code>
 gestisca correttamente il caso in cui l'elemento specificato non sia presente
 all'interno del range della sottolista. Si vuole garantire che, in tale scenario,
 il metodo non alteri lo stato della lista e restituisca il valore booleano appropriato (`false`).
 <p>
 Test Description: 1) Si verifica la dimensione iniziale della `subList` (attesa: 3).
                   2) Si tenta di rimuovere un elemento ("non_esiste") che non è presente nella `subList`
                      tramite il metodo <code>remove(Object)</code>.
                   3) Si verifica che il metodo <code>remove()</code> restituisca <code>false</code>, indicando che l'elemento
                      non è stato trovato e, di conseguenza, non è stato rimosso.
                   4) Si verifica che la dimensione della `subList` sia rimasta invariata (attesa: 3),
                      confermando che nessuna modifica è stata apportata alla lista.
 <p>
 Preconditions: La sottolista è inizializzata e contiene gli elementi ["uno", "due", "tre"].
 L'elemento "non_esiste" non è presente nella sottolista né nella lista padre.
 <p>
 Postconditions: La sottolista rimane invariata; la sua dimensione e i suoi contenuti non sono stati modificati.
 <p>
 Expected Result: <code>remove("non_esiste")</code> deve restituire <code>false</code>.
 La dimensione della sottolista non deve cambiare.</div>
</section>
</li>
<li>
<section class="detail" id="testRemoveNullElementByObject()">
<h3>testRemoveNullElementByObject</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRemoveNullElementByObject</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#remove(java.lang.Object)"><code>HCollection.remove(Object)</code></a>.
 <p>
 Summary: Il test verifica la rimozione di un elemento <code>null</code> dalla sottolista,
 assicurando che l'operazione sia correttamente gestita e si rifletta sulla dimensione e sul contenuto.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che il metodo <code>remove(Object o)</code>
 sia in grado di trovare e rimuovere correttamente un elemento <code>null</code> dalla sottolista.
 Questo assicura la corretta gestione dei valori <code>null</code> all'interno delle operazioni della lista.
 <p>
 Test Description: 1) Un elemento <code>null</code> viene inserito nella `subList` ad una posizione specifica (indice 1),
                      trasformando la sottolista in `["uno", null, "due", "tre"]`.
                   2) Si verifica la dimensione della `subList` dopo l'aggiunta (attesa: 4).
                   3) Si tenta di rimuovere l'elemento <code>null</code> dalla `subList` tramite il metodo <code>remove(Object)</code>.
                   4) Si verifica che il metodo <code>remove()</code> restituisca <code>true</code>, indicando che l'elemento è stato rimosso.
                   5) Si verifica che la dimensione della `subList` sia diminuita correttamente (attesa: 3).
                   6) Si assicura che gli elementi rimanenti nella `subList` siano ora nell'ordine corretto:
                      "uno" all'indice 0, "due" all'indice 1 e "tre" all'indice 2.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 Un elemento <code>null</code> viene aggiunto alla sottolista all'indice 1 prima della chiamata a <code>remove()</code>.
 <p>
 Postconditions: La sottolista è modificata e l'elemento <code>null</code> è stato rimosso.
 La sua dimensione è diminuita di uno.
 <p>
 Expected Result: <code>remove(null)</code> deve restituire <code>true</code> e l'elemento <code>null</code> deve essere rimosso,
 lasciando la sottolista come `["uno", "due", "tre"]`.</div>
</section>
</li>
<li>
<section class="detail" id="testSetElement()">
<h3>testSetElement</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testSetElement</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#set(int,java.lang.Object)"><code>HList.set(int, Object)</code></a>.
 <p>
 Summary: Il test verifica la modifica di un elemento esistente in una posizione specifica (indice)
 all'interno della sottolista, assicurando che l'aggiornamento si rifletta correttamente
 sia nella sottolista che nella lista padre sottostante.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che il metodo <code>set(int index, Object element)</code>
 sulla sottolista aggiorni l'elemento all'indice specificato. Si vuole anche assicurare
 che questa modifica venga propagata correttamente alla lista padre nella posizione corrispondente,
 in modo che entrambe le viste (sottolista e lista padre) mantengano la coerenza.
 <p>
 Test Description: 1) Si verifica il valore iniziale dell'elemento all'indice 1 della `subList` (atteso: "due").
                   2) Si invoca il metodo <code>set()</code> sulla `subList`, modificando l'elemento all'indice 1
                      con il nuovo valore "modificato".
                   3) Si verifica che il metodo <code>set()</code> restituisca l'elemento precedentemente presente ("due").
                   4) Si assicura che l'elemento all'indice 1 della `subList` sia stato correttamente aggiornato a "modificato".
                   5) Infine, si verifica che la modifica sia stata correttamente applicata anche nella `parentList`,
                      controllando il valore all'indice corrispondente (offset della `subList` + indice nella `subList`).
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La lista padre è stata inizializzata e contiene, ad esempio, ["zero", "uno", "due", "tre", "quattro", "cinque"],
 dove gli elementi della sottolista sono un sottoinsieme contiguo.
 <p>
 Postconditions: La sottolista è modificata e ora contiene gli elementi ["uno", "modificato", "tre"].
 La lista padre è aggiornata di conseguenza, con l'elemento all'indice corrispondente modificato.
 La dimensione della sottolista rimane invariata.
 <p>
 Expected Result: L'elemento all'indice 1 della sottolista deve essere "modificato",
 e il metodo <code>set()</code> deve restituire il vecchio elemento ("due").
 La modifica deve essere visibile anche nella lista padre.</div>
</section>
</li>
<li>
<section class="detail" id="testSetNegativeIndex()">
<h3>testSetNegativeIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testSetNegativeIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#set(int,java.lang.Object)"><code>HList.set(int, Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>set(int index, Object element)</code> lanci
 una <code>IndexOutOfBoundsException</code> quando si tenta di modificare un elemento
 specificando un indice negativo.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità
 alla specifica di set(), che impone il lancio di una
 <code>IndexOutOfBoundsException</code> per qualsiasi indice che non sia compreso tra 0 (incluso) e `size()` (escluso).
 Questo caso specifico si concentra sulla violazione del limite inferiore dell'indice.
 <p>
 Test Description: 1) Si tenta di modificare un elemento nella `subList`
                       tramite il metodo <code>set(int, Object)</code>.
                   2) Viene fornito un indice intenzionalmente negativo (`-1`).
                   3) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene elementi (ad esempio, ["uno", "due", "tre"]).
 <p>
 Postconditions: La sottolista rimane invariata, poiché l'operazione di modifica non è stata
 completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>IndexOutOfBoundsException</code> deve essere lanciata quando si chiama <code>set(-1, "test")</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testSetOutOfBoundsIndex()">
<h3>testSetOutOfBoundsIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testSetOutOfBoundsIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#set(int,java.lang.Object)"><code>HList.set(int, Object)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>set(int index, Object element)</code> lanci
 una <code>IndexOutOfBoundsException</code> quando si tenta di modificare un elemento
 specificando un indice che è al di fuori dei limiti validi (ovvero, maggiore o uguale alla dimensione).
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità
 alla specifica di set(), che impone il lancio di una
 <code>IndexOutOfBoundsException</code> per qualsiasi indice non compreso tra 0 (incluso) e `size()` (escluso).
 Questo caso specifico si concentra sulla violazione del limite superiore dell'indice.
 <p>
 Test Description: 1) Si tenta di modificare un elemento nella `subList`
                      tramite il metodo <code>set(int, Object)</code>.
                   2) Viene fornito un indice intenzionalmente fuori limite, pari a <code>3</code>,
                      mentre la dimensione della sottolista è <code>3</code> (gli indici validi sono da <code>0</code> a <code>2</code>).
                   3) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene 3 elementi (ad esempio, ["uno", "due", "tre"]).
 <p>
 Postconditions: La sottolista rimane invariata, poiché l'operazione di modifica non è stata
 completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>IndexOutOfBoundsException</code> deve essere lanciata quando si chiama <code>set(3, "test")</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testClearSubList()">
<h3>testClearSubList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testClearSubList</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#clear()"><code>HCollection.clear()</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>clear()</code> svuoti completamente la sottolista
 e rimuova gli elementi corrispondenti dalla lista padre sottostante.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che <code>clear()</code> sulla sottolista
 rimuova tutti gli elementi contenuti nel suo range dalla lista padre. Si vuole anche assicurare
 che la sottolista stessa diventi effettivamente vuota, con la sua dimensione impostata a zero.
 <p>
 Test Description: 1) Si verifica la dimensione iniziale della `subList` (attesa: 3).
                   2) Si invoca il metodo <code>clear()</code> sulla `subList`.
                   3) Si verifica che la dimensione della `subList` sia ora <code>0</code> e che <code>isEmpty()</code> restituisca <code>true</code>.
                   4) Si verifica che gli elementi che facevano parte della `subList` siano stati effettivamente
                      rimossi dalla `parentList`. Si controlla la nuova dimensione della `parentList` (attesa: 3 da 6)
                      e la posizione degli elementi che non erano nel range della `subList` (es. "zero", "quattro", "cinque").
 <p>
 Preconditions: La sottolista è inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 La lista padre è inizializzata e contiene gli elementi `["zero", "uno", "due", "tre", "quattro", "cinque"]`,
 dove la sottolista è una vista degli elementi centrali.
 <p>
 Postconditions: La sottolista è vuota. La lista padre è modificata e contiene solo gli elementi
 che non rientravano nel range originale della sottolista (es. `["zero", "quattro", "cinque"]`).
 <p>
 Expected Result: La sottolista deve essere vuota (dimensione <code>0</code>).
 La lista padre deve contenere solo gli elementi che erano esterni al range iniziale della sottolista,
 con gli elementi successivi all'intervallo spostati per coprire il "buco" lasciato dagli elementi rimossi.</div>
</section>
</li>
<li>
<section class="detail" id="testAddAllCollection()">
<h3>testAddAllCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddAllCollection</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#addAll(myAdapter.HCollection)"><code>HCollection.addAll(HCollection)</code></a>.
 <p>
 Summary: Il test verifica l'aggiunta di tutti gli elementi di una collezione specificata
 alla fine della sottolista, assicurando che l'operazione mantenga l'ordine degli elementi
 e aggiorni correttamente le dimensioni sia della sottolista che della lista padre.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che <code>addAll(HCollection c)</code>
 sulla sottolista deleghi correttamente l'inserimento multiplo di elementi alla lista padre,
 posizionandoli alla fine della vista della sottolista. Si vuole assicurare che tutti gli elementi
 della collezione fornita vengano aggiunti, che mantengano il loro ordine relativo,
 e che gli elementi della lista padre successivi alla sottolista vengano correttamente spostati.
 <p>
 Test Description: 1) Viene creata una nuova collezione (`collectionToAdd`) e popolata con
                      gli elementi "x" e "y".
                   2) Si invoca il metodo <code>addAll()</code> sulla `subList` (che contiene inizialmente ["uno", "due", "tre"]),
                      passando `collectionToAdd` come argomento.
                   3) Si verifica che il metodo <code>addAll()</code> restituisca <code>true</code>, indicando che la sottolista è stata modificata.
                   4) Si verifica che la dimensione della `subList` sia aumentata correttamente (da 3 a 5).
                   5) Si assicura che gli elementi "x" e "y" siano stati aggiunti correttamente alla fine della `subList`
                      (agli indici 3 e 4 rispettivamente).
                   6) Infine, si verifica che l'aggiunta si sia propagata correttamente alla `parentList`,
                      controllando le posizioni degli elementi aggiunti e lo spostamento degli elementi originali successivi.
 <p>
 Preconditions: La sottolista è inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La lista padre è inizializzata e contiene gli elementi ["zero", "uno", "due", "tre", "quattro", "cinque"].
 La `collectionToAdd` viene creata e contiene gli elementi ["x", "y"].
 <p>
 Postconditions: La sottolista è modificata e ora contiene gli elementi ["uno", "due", "tre", "x", "y"].
 La lista padre è aggiornata e ora contiene gli elementi ["zero", "uno", "due", "tre", "x", "y", "quattro", "cinque"].
 La dimensione della sottolista è aumentata in base al numero di elementi aggiunti.
 <p>
 Expected Result: <code>addAll(collectionToAdd)</code> deve restituire <code>true</code>.
 La dimensione della sottolista deve essere <code>5</code>.
 Gli elementi "x" e "y" devono essere presenti agli indici finali della sottolista e alle posizioni corrispondenti nella lista padre.
 Gli elementi originali della lista padre successivi al range iniziale della sottolista devono essere spostati.</div>
</section>
</li>
<li>
<section class="detail" id="testAddAllEmptyCollection()">
<h3>testAddAllEmptyCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddAllEmptyCollection</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#addAll(myAdapter.HCollection)"><code>HCollection.addAll(HCollection)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>addAll(HCollection c)</code> restituisca <code>false</code>
 quando la collezione specificata come argomento è vuota, e che la sottolista non venga modificata.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare che <code>addAll()</code>
 gestisca correttamente il caso in cui non ci siano elementi da aggiungere. In tale scenario,
 la lista non dovrebbe essere modificata e il metodo dovrebbe indicare l'assenza di modifiche
 restituendo <code>false</code>, come specificato dal contratto di <code>Collection.addAll()</code>.
 <p>
 Test Description: 1) Viene creata una nuova collezione (`emptyCollection`) che non contiene alcun elemento.
                   2) Si invoca il metodo <code>addAll()</code> sulla `subList` (che contiene inizialmente ["uno", "due", "tre"]),
                      passando `emptyCollection` come argomento.
                   3) Si verifica che il metodo <code>addAll()</code> restituisca <code>false</code>, indicando che la sottolista
                      non è stata modificata.
                   4) Si verifica che la dimensione della `subList` sia rimasta invariata (attesa: 3),
                      confermando che nessuna modifica è stata apportata alla lista.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene elementi ["uno", "due", "tre"].
 La `emptyCollection` viene creata e rimane vuota.
 <p>
 Postconditions: La sottolista rimane invariata; la sua dimensione e i suoi contenuti non sono stati modificati.
 <p>
 Expected Result: <code>addAll(emptyCollection)</code> deve restituire <code>false</code>.
 La dimensione della sottolista non deve cambiare.</div>
</section>
</li>
<li>
<section class="detail" id="testAddAllNullCollection()">
<h3>testAddAllNullCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddAllNullCollection</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#addAll(myAdapter.HCollection)"><code>HCollection.addAll(HCollection)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>addAll(HCollection c)</code> lanci
 una <code>NullPointerException</code> quando la collezione specificata come argomento è <code>null</code>.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità
  alla specifica di addAll(), che impone il lancio di una
 <code>NullPointerException</code> se la collezione fornita è un riferimento <code>null</code>. Questo test
 convalida il comportamento atteso per un input non valido.
 <p>
 Test Description: 1) Si tenta di aggiungere elementi alla `subList` tramite il metodo <code>addAll()</code>.
                   2) Viene passato <code>null</code> come argomento per la collezione.
                   3) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>NullPointerException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene elementi ["uno", "due", "tre"].
 L'argomento passato a <code>addAll()</code> è <code>null</code>.
 <p>
 Postconditions: La sottolista rimane invariata, poiché l'operazione non è completata con successo
 a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>NullPointerException</code> deve essere lanciata quando si chiama <code>addAll(null)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testAddAllCollectionAtIndex()">
<h3>testAddAllCollectionAtIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddAllCollectionAtIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#addAll(int,myAdapter.HCollection)"><code>HList.addAll(int, HCollection)</code></a>.
 <p>
 Summary: Il test verifica l'aggiunta di tutti gli elementi di una collezione specificata
 in una posizione (indice) specifica all'interno della sottolista, assicurando che
 l'inserimento sposti correttamente gli elementi esistenti e aggiorni le dimensioni
 sia della sottolista che della lista padre.
 <p>
 Test Case Design: La motivazione dietro a questo test è garantire che <code>addAll(int index, HCollection c)</code>
 sulla sottolista funzioni correttamente per gli inserimenti multipli in posizioni intermedie.
 Ciò implica che gli elementi della collezione vengano inseriti all'indice specificato della sottolista,
 che gli elementi successivi nella sottolista (e di conseguenza nella lista padre) vengano spostati in avanti,
 e che la dimensione della sottolista si aggiorni correttamente.
 <p>
 Test Description: 1) Viene creata una nuova collezione (`collectionToAdd`) e popolata con
                      gli elementi "x" e "y".
                   2) Si invoca il metodo <code>addAll()</code> sulla `subList` (che contiene inizialmente ["uno", "due", "tre"]),
                      passando l'indice <code>1</code> e `collectionToAdd` come argomenti. Questo inserirà "x" e "y"
                      all'indice 1 della sottolista.
                   3) Si verifica che il metodo <code>addAll()</code> restituisca <code>true</code>, indicando che la sottolista è stata modificata.
                   4) Si verifica che la dimensione della `subList` sia aumentata correttamente (da 3 a 5).
                   5) Si assicura che gli elementi della `subList` siano ora nell'ordine corretto:
                      "uno" all'indice 0, "x" all'indice 1, "y" all'indice 2, "due" all'indice 3 e "tre" all'indice 4.
                   6) Infine, si verifica che l'inserimento si sia propagato correttamente alla `parentList`,
                      controllando le posizioni degli elementi aggiunti e lo spostamento degli elementi originali.
 <p>
 Preconditions: La sottolista è inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La lista padre è inizializzata e contiene gli elementi ["zero", "uno", "due", "tre", "quattro", "cinque"].
 La `collectionToAdd` viene creata e contiene gli elementi ["x", "y"].
 <p>
 Postconditions: La sottolista è modificata e ora contiene gli elementi ["uno", "x", "y", "due", "tre"].
 La lista padre è aggiornata di conseguenza, con gli elementi aggiunti nella posizione corretta
 e gli elementi successivi spostati. La dimensione della sottolista è aumentata in base
 al numero di elementi aggiunti.
 <p>
 Expected Result: <code>addAll(1, collectionToAdd)</code> deve restituire <code>true</code>.
 La dimensione della sottolista deve essere <code>5</code>.
 Gli elementi devono essere aggiunti nella posizione specificata, e le liste devono mantenere la coerenza.</div>
</section>
</li>
<li>
<section class="detail" id="testAddAllAtIndexNegativeIndex()">
<h3>testAddAllAtIndexNegativeIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddAllAtIndexNegativeIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#addAll(int,myAdapter.HCollection)"><code>HList.addAll(int, HCollection)</code></a>.
 <p>
 Summary: Il test verifica che il metodo <code>addAll(int index, HCollection c)</code> lanci
 una <code>IndexOutOfBoundsException</code> quando si tenta di aggiungere una collezione di elementi
 specificando un indice negativo.
 <p>
 Test Case Design: La motivazione dietro a questo test è assicurare la completa conformità
 alla specifica di addAll(int, Collection), che impone il lancio di una
 <code>IndexOutOfBoundsException</code> per qualsiasi indice che non sia compreso tra 0 (incluso) e `size()` (incluso).
 Questo caso specifico si concentra sulla violazione del limite inferiore dell'indice.
 <p>
 Test Description: 1) Viene creata una piccola collezione (`collectionToAdd`) con un elemento.
                   2) Si tenta di aggiungere questa collezione alla `subList` tramite il metodo <code>addAll(int, HCollection)</code>.
                   3) Viene fornito un indice intenzionalmente negativo (`-1`).
                   4) Il test si aspetta che, come risultato di questa operazione,
                      venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La sottolista è stata inizializzata e contiene elementi ["uno", "due", "tre"].
 Una collezione (`collectionToAdd`) è stata creata e contiene almeno un elemento.
 <p>
 Postconditions: La sottolista rimane invariata, poiché l'operazione di aggiunta non è stata
 completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Una <code>IndexOutOfBoundsException</code> deve essere lanciata quando si chiama <code>addAll(-1, collectionToAdd)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testAddAllAtIndexOutOfBoundsIndex()">
<h3>testAddAllAtIndexOutOfBoundsIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testAddAllAtIndexOutOfBoundsIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#addAll(int,myAdapter.HCollection)"><code>HList.addAll(int, HCollection)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>addAll(int index, HCollection c)</code> lanci
 una <code>IndexOutOfBoundsException</code> quando si tenta di inserire una collezione di elementi
 a un indice che è al di fuori dei limiti validi della sottolista (ovvero, un indice maggiore della sua dimensione).
 <p>
 Test Case Design: La ragione principale di questo test è assicurare la piena **conformità alla specifica di addAll(int, Collection). 
 Questa specifica impone che venga lanciata una
 <code>IndexOutOfBoundsException</code> per qualsiasi indice non compreso tra 0 (incluso) e `size()` (incluso).
 Nello specifico, questo test si concentra sulla violazione del limite superiore dell'indice, garantendo che il metodo
 si comporti correttamente quando l'indice fornito non è valido per l'inserimento.
 <p>
 Test Description:
 1) Viene preparata una piccola collezione, `collectionToAdd`, contenente un elemento.
 2) Si tenta di invocare il metodo <code>addAll()</code> sulla `subList`, passando l'indice <code>4</code>
 e la `collectionToAdd`. Dato che la `subList` ha una dimensione di 3 (indici validi da 0 a 2 per l'accesso,
 e fino a 3 per l'aggiunta in coda), l'indice 4 è considerato fuori limite.
 3) Il test prevede che questa operazione si concluda con il lancio di una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene 3 elementi (ad esempio, `["uno", "due", "tre"]`).
 La `collectionToAdd` è stata creata e contiene almeno un elemento (ad esempio, `["a"]`).
 <p>
 Postconditions: La `subList` rimane invariata, poiché l'operazione di aggiunta non è andata a buon fine
 a causa dell'eccezione lanciata.
 <p>
 Expected Result: Ci si aspetta il lancio di una **<code>IndexOutOfBoundsException</code>** quando si chiama <code>addAll(4, collectionToAdd)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testRemoveAllCollection()">
<h3>testRemoveAllCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRemoveAllCollection</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#removeAll(myAdapter.HCollection)"><code>HCollection.removeAll(HCollection)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>removeAll(HCollection c)</code> rimuova correttamente
 dalla sottolista **tutti gli elementi che sono contenuti anche nella collezione specificata**,
 assicurando che le modifiche si riflettano sia nella sottolista che nella lista padre.
 <p>
 Test Case Design: L'obiettivo di questo test è garantire che <code>removeAll()</code> sulla sottolista
 filtri e rimuova solo gli elementi che esistono simultaneamente nella sottolista e nella collezione fornita.
 Si vuole inoltre assicurare che questa operazione influenzi la lista padre delegando correttamente la rimozione,
 e che gli elementi rimanenti si riposizionino correttamente, aggiornando le dimensioni di entrambe le liste.
 <p>
 Test Description:
 1) Viene creata una `collectionToRemove` e popolata con gli elementi `"uno"` e `"tre"`, che sono presenti nella `subList`.
 2) Viene invocato il metodo <code>removeAll()</code> sulla `subList` (inizialmente `["uno", "due", "tre"]`),
    passando `collectionToRemove` come argomento.
 3) Il test verifica che <code>removeAll()</code> restituisca <code>true</code>, confermando che la `subList` è stata modificata.
 4) Si assicura che la dimensione della `subList` sia ora `1` e che l'unico elemento rimasto sia `"due"`.
 5) Infine, si verifica lo stato della `parentList`: ci si aspetta che gli elementi `"uno"` e `"tre"`
    (che corrispondevano agli elementi della `subList`) siano stati rimossi, e che gli elementi successivi
    si siano spostati per riempire gli spazi. Si controlla la nuova dimensione della `parentList` e l'ordine dei suoi elementi.
 <p>
 Preconditions: La `subList` è inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 La `parentList` è inizializzata e contiene, ad esempio, `["zero", "uno", "due", "tre", "quattro", "cinque"]`.
 La `collectionToRemove` è creata e contiene gli elementi `["uno", "tre"]`.
 <p>
 Postconditions: La `subList` è modificata e ora contiene solo l'elemento `["due"]`.
 La `parentList` è aggiornata di conseguenza, con gli elementi corrispondenti rimossi e gli altri spostati.
 La dimensione della `subList` è diminuita.
 <p>
 Expected Result: <code>removeAll(collectionToRemove)</code> deve restituire **<code>true</code>**.
 La dimensione della `subList` deve essere **<code>1</code>**, e deve contenere solo **"due"**.
 La `parentList` deve riflettere la rimozione di "uno" e "tre", risultando in uno stato come `["zero", "due", "quattro", "cinque"]`.</div>
</section>
</li>
<li>
<section class="detail" id="testRemoveAllNoMatchingElements()">
<h3>testRemoveAllNoMatchingElements</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRemoveAllNoMatchingElements</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#removeAll(myAdapter.HCollection)"><code>HCollection.removeAll(HCollection)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>removeAll(HCollection c)</code> restituisca <code>false</code>
 e non modifichi la sottolista quando nessuno degli elementi nella collezione specificata
 è presente all'interno della sottolista.
 <p>
 Test Case Design: La motivazione di questo test è garantire che <code>removeAll()</code> sulla sottolista
 si comporti correttamente in assenza di intersezioni tra la sottolista stessa e la collezione fornita.
 È fondamentale che il metodo non apporti modifiche e indichi questa assenza di modifiche
 restituendo <code>false</code>, in linea con il contratto di <code>removeAll()</code>.
 <p>
 Test Description:
 1) Viene creata una `collectionToRemove` e popolata con elementi (`"sette"`, `"otto"`)
    che sono noti non essere presenti nella `subList`.
 2) Si invoca il metodo <code>removeAll()</code> sulla `subList` (che contiene inizialmente `["uno", "due", "tre"]`),
    passando `collectionToRemove` come argomento.
 3) Il test verifica che <code>removeAll()</code> restituisca <code>false</code>, a indicare che nessun elemento è stato rimosso
    e quindi la sottolista non è stata modificata.
 4) Si assicura che la dimensione della `subList` sia rimasta invariata (`3`), confermando che
    l'operazione non ha avuto alcun impatto sulla lista.
 <p>
 Preconditions: La `subList` è inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 La `collectionToRemove` è creata e contiene gli elementi `["sette", "otto"]`, nessuno dei quali è presente nella `subList`.
 <p>
 Postconditions: La `subList` rimane invariata; la sua dimensione e i suoi contenuti non sono stati modificati.
 <p>
 Expected Result: <code>removeAll(collectionToRemove)</code> deve restituire **<code>false</code>**.
 La dimensione della `subList` non deve cambiare.</div>
</section>
</li>
<li>
<section class="detail" id="testRemoveAllNullCollection()">
<h3>testRemoveAllNullCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRemoveAllNullCollection</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#removeAll(myAdapter.HCollection)"><code>HCollection.removeAll(HCollection)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>removeAll(HCollection c)</code> lanci
 una <code>NullPointerException</code> quando la collezione specificata come argomento è <code>null</code>.
 <p>
 Test Case Design: La motivazione principale dietro a questo test è garantire la completa
 conformità di removeAll(). Questa specifica
 impone esplicitamente il lancio di una <code>NullPointerException</code> nel caso in cui
 l'argomento `c` (la collezione da rimuovere) sia un riferimento <code>null</code>. Questo test
 convalida il comportamento atteso del metodo di fronte a un input non valido.
 <p>
 Test Description:
 1) Si tenta di invocare il metodo <code>removeAll()</code> sulla `subList`.
 2) Viene intenzionalmente passato un riferimento <code>null</code> come argomento per la collezione da rimuovere.
 3) Il test prevede che, come risultato di questa operazione, venga lanciata una <code>NullPointerException</code>.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene elementi (ad esempio, `["uno", "due", "tre"]`).
 L'argomento passato a <code>removeAll()</code> è <code>null</code>.
 <p>
 Postconditions: La `subList` rimane invariata, poiché l'operazione di rimozione non è stata
 completata con successo a causa dell'eccezione lanciata.
 <p>
 Expected Result: Ci si aspetta il lancio di una **<code>NullPointerException</code>** quando si chiama <code>removeAll(null)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testRetainAllCollection()">
<h3>testRetainAllCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRetainAllCollection</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#retainAll(myAdapter.HCollection)"><code>HCollection.retainAll(HCollection)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>retainAll(HCollection c)</code> mantenga nella sottolista
 **solo gli elementi che sono contenuti anche nella collezione specificata**, rimuovendo tutti gli altri,
 e assicurando che le modifiche si riflettano correttamente sia nella sottolista che nella lista padre.
 <p>
 Test Case Design: La motivazione di questo test è garantire che <code>retainAll()</code> sulla sottolista
 funzioni come un'operazione di intersezione, rimuovendo tutti gli elementi che non sono presenti
 nella collezione fornita. È fondamentale che questa operazione si propaghi correttamente alla lista padre,
 e che gli elementi rimanenti si riposizionino correttamente, aggiornando le dimensioni di entrambe le liste.
 <p>
 Test Description:
 1) Viene creata una `collectionToRetain` e popolata con gli elementi `"due"` e `"quattro"`.
    Nota: `"due"` è presente nella `subList`, mentre `"quattro"` non lo è (ma potrebbe esserlo nella `parentList`).
 2) Viene invocato il metodo <code>retainAll()</code> sulla `subList` (inizialmente `["uno", "due", "tre"]`),
    passando `collectionToRetain` come argomento. Ci si aspetta che solo `"due"` rimanga.
 3) Il test verifica che <code>retainAll()</code> restituisca <code>true</code>, confermando che la `subList` è stata modificata
    (poiché "uno" e "tre" sono stati rimossi).
 4) Si assicura che la dimensione della `subList` sia ora `1` e che l'unico elemento rimasto sia `"due"`.
 5) Infine, si verifica lo stato della `parentList`: ci si aspetta che gli elementi `"uno"` e `"tre"`
    (che facevano parte del range della `subList` e non erano nella `collectionToRetain`) siano stati rimossi.
    Si controlla la nuova dimensione della `parentList` e l'ordine dei suoi elementi.
 <p>
 Preconditions: La `subList` è inizializzata e contiene gli elementi ["uno", "due", "tre"].
 La `parentList` è inizializzata e contiene, ad esempio, ["zero", "uno", "due", "tre", "quattro", "cinque"].
 La `collectionToRetain` è creata e contiene gli elementi ["due", "quattro"].
 <p>
 Postconditions: La `subList` è modificata e ora contiene solo l'elemento `["due"]`.
 La `parentList` è aggiornata di conseguenza, con gli elementi rimossi e gli altri spostati.
 La dimensione della `subList` è diminuita.
 <p>
 Expected Result: <code>retainAll(collectionToRetain)</code> deve restituire **<code>true</code>**.
 La dimensione della `subList` deve essere **<code>1</code>**, e deve contenere solo **"due"**.
 La `parentList` deve riflettere la rimozione di "uno" e "tre", risultando in uno stato con "zero", "due", "quattro", "cinque"
 e con una dimensione aggiornata a 4.</div>
</section>
</li>
<li>
<section class="detail" id="testRetainAllNoModification()">
<h3>testRetainAllNoModification</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRetainAllNoModification</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#retainAll(myAdapter.HCollection)"><code>HCollection.retainAll(HCollection)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>retainAll(HCollection c)</code> restituisca <code>false</code>
 e non modifichi la sottolista quando tutti gli elementi attualmente presenti nella sottolista
 sono anche contenuti nella collezione specificata, indicando che non sono necessarie modifiche.
 <p>
 Test Case Design: L'obiettivo principale di questo test è garantire che <code>retainAll()</code> sulla sottolista
 si comporti correttamente nel caso in cui tutti i suoi elementi debbano essere mantenuti. Le specifiche di
 <code>retainAll()</code> prevede che il metodo restituisca <code>false</code> se la collezione non subisce modifiche.
 Questo test convalida tale comportamento, assicurando che la lista non venga inutilmente alterata
 e che il valore di ritorno sia appropriato quando non ci sono elementi da rimuovere.
 <p>
 Test Description:
 1) Viene creata una `collectionToRetain` e popolata con gli elementi `"uno"`, `"due"`, `"tre"` (che sono tutti presenti nella `subList`)
 e `"sette"` (un elemento aggiuntivo non presente nella `subList`).
 2) Viene invocato il metodo <code>retainAll()</code> sulla `subList` (inizialmente `["uno", "due", "tre"]`),
 passando `collectionToRetain` come argomento. Ci si aspetta che tutti gli elementi della `subList` siano da mantenere.
 3) Il test verifica che <code>retainAll()</code> restituisca **<code>false</code>**, confermando che la `subList`
 non è stata modificata poiché tutti i suoi elementi erano già presenti nella `collectionToRetain`.
 4) Si assicura che la dimensione della `subList` sia rimasta invariata (`3`) e che i suoi elementi
 siano ancora nell'ordine e nel contenuto originali: `"uno"` all'indice 0, `"due"` all'indice 1 e `"tre"` all'indice 2.
 <p>
 Preconditions: La `subList` è inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 La `collectionToRetain` è creata e contiene elementi che includono tutti quelli della `subList`
 ["uno", "due", "tre", "sette"].
 <p>
 Postconditions: La `subList` rimane completamente invariata; la sua dimensione e i suoi contenuti non sono stati modificati.
 La `parentList` rimane anch'essa invariata.
 <p>
 Expected Result: <code>retainAll(collectionToRetain)</code> deve restituire **<code>false</code>**.
 La dimensione della `subList` deve rimanere **<code>3</code>**, e i suoi elementi devono essere ancora **`["uno", "due", "tre"]`**.</div>
</section>
</li>
<li>
<section class="detail" id="testRetainAllClearSubList()">
<h3>testRetainAllClearSubList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRetainAllClearSubList</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#retainAll(myAdapter.HCollection)"><code>HCollection.retainAll(HCollection)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>retainAll(HCollection c)</code> svuoti completamente la sottolista
 (e rimuova gli elementi corrispondenti dalla lista padre) quando nessuno degli elementi
 della sottolista è presente nella collezione specificata.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire che <code>retainAll()</code> sulla sottolista
 si comporti correttamente quando non c'è alcuna intersezione tra i suoi elementi e quelli della collezione fornita.
 In questo scenario, tutti gli elementi della sottolista dovrebbero essere rimossi, e il metodo dovrebbe
 restituire <code>true</code> per indicare che la lista è stata modificata. Si vuole anche assicurare che
 la rimozione si propaghi correttamente alla lista padre.
 <p>
 Test Description:
 1) Viene creata una `collectionToRetain` e popolata con elementi (`"sette"`, `"otto"`)
    che non sono presenti nella `subList` (inizialmente `["uno", "due", "tre"]`).
 2) Si invoca il metodo <code>retainAll()</code> sulla `subList`, passando `collectionToRetain` come argomento.
 3) Il test verifica che <code>retainAll()</code> restituisca **<code>true</code>**, confermando che la `subList`
    è stata modificata (svuotata).
 4) Si assicura che la `subList` sia ora **vuota** e che la sua dimensione sia **<code>0</code>**.
 5) Infine, si verifica lo stato della `parentList`: ci si aspetta che tutti gli elementi che facevano
    parte del range della `subList` ("uno", "due", "tre") siano stati rimossi dalla `parentList`.
    Si controlla la nuova dimensione della `parentList` e l'ordine dei suoi elementi rimanenti.
 <p>
 Preconditions: La `subList` è inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 La `parentList` è inizializzata e contiene `["zero", "uno", "due", "tre", "quattro", "cinque"]`.
 La `collectionToRetain` è creata e contiene elementi (`"sette"`, `"otto"`) che non sono presenti nella `subList`.
 <p>
 Postconditions: La `subList` è modificata e diventa vuota.
 La `parentList` è aggiornata di conseguenza, con gli elementi corrispondenti rimossi e gli altri spostati.
 La dimensione della `subList` è diminuita a zero.
 <p>
 Expected Result: <code>retainAll(collectionToRetain)</code> deve restituire **<code>true</code>**.
 La `subList` deve essere **vuota** (dimensione <code>0</code>).
 La `parentList` deve riflettere la rimozione di "uno", "due" e "tre", risultando in uno stato come
 `["zero", "quattro", "cinque"]` e con una dimensione aggiornata a 3.</div>
</section>
</li>
<li>
<section class="detail" id="testRetainAllNullCollection()">
<h3>testRetainAllNullCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testRetainAllNullCollection</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#retainAll(myAdapter.HCollection)"><code>HCollection.retainAll(HCollection)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>retainAll(HCollection c)</code> lanci
 una <code>NullPointerException</code> quando la collezione specificata come argomento è <code>null</code>.
 <p>
 Test Case Design: La ragione principale di questo test è assicurare la piena conformità
 di retainAll(). Questa specifica impone esplicitamente il lancio di una
 <code>NullPointerException</code> nel caso in cui l'argomento `c` (la collezione da confrontare) sia un riferimento <code>null</code>.
 Questo test convalida il comportamento atteso per un input non valido.
 <p>
 Test Description:
 1) Si tenta di invocare il metodo <code>retainAll()</code> sulla `subList`.
 2) Viene intenzionalmente passato un riferimento <code>null</code> come argomento per la collezione.
 3) Il test prevede che, come risultato di questa operazione, venga lanciata una <code>NullPointerException</code>.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene elementi `["uno", "due", "tre"]`.
 L'argomento passato a <code>retainAll()</code> è <code>null</code>.
 <p>
 Postconditions: La `subList` rimane invariata, poiché l'operazione non è stata completata
 a causa dell'eccezione lanciata.
 <p>
 Expected Result: Ci si aspetta il lancio di una **<code>NullPointerException</code>** quando si chiama <code>retainAll(null)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testParentSetReflectsInSubList()">
<h3>testParentSetReflectsInSubList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testParentSetReflectsInSubList</span>()</div>
<div class="block">Test di interazione: modifica sulla lista padre si riflette nella sottolista.
 <p>
 Summary: Questo test verifica che una modifica non strutturale (sostituzione di un elemento)
 effettuata sulla lista padre si rifletta immediatamente e correttamente nella sottolista,
 purché la modifica avvenga all'interno del range di elementi visualizzati dalla sottolista.
 <p>
 Test Case Design: Questo test è cruciale per validare uno dei comportamenti fondamentali delle "views" (come una sub-list).
 Le modifiche non strutturali (ad esempio, l'aggiornamento del valore di un elemento tramite <code>set()</code>)
 dovrebbero propagarsi istantaneamente e bidirezionalmente tra la vista (la sottolista) e la lista di supporto (la lista padre).
 Questo assicura la coerenza dei dati indipendentemente da quale interfaccia venga utilizzata per la modifica.
 <p>
 Test Description:
 1) Viene modificato un elemento nella `parentList` utilizzando il metodo <code>set()</code>.
    In questo caso, l'elemento all'indice `2` della `parentList` (che corrisponde all'elemento `"due"` e all'indice `1` nella `subList`)
    viene cambiato in `"new value"`.
 2) Si verifica immediatamente il valore dell'elemento corrispondente nella `subList` tramite <code>subList.get(1)</code>.
 <p>
 Preconditions: La `subList` è stata inizializzata e visualizza un sottoinsieme della `parentList`.
 `subList` è `["uno", "due", "tre"]`, e la `parentList` è `["zero", "uno", "due", "tre", "quattro", "cinque"]`,
 con "uno" all'indice 1 della parentList, "due" all'indice 2, e "tre" all'indice 3.
 <p>
 Postconditions: L'elemento all'indice 2 della `parentList` (e quindi all'indice 1 della `subList`)
 è stato aggiornato a `"new value"`. La `subList` riflette questo cambiamento senza alcuna operazione esplicita su di essa.
 La `parentList` sarà ora `["zero", "uno", "new value", "tre", "quattro", "cinque"]`.
 <p>
 Expected Result: L'invocazione di <code>subList.get(1)</code> deve restituire la stringa **"new value"**,
 confermando che la modifica sulla lista padre è stata propagata con successo alla sottolista.</div>
</section>
</li>
<li>
<section class="detail" id="testParentStructuralModificationReflectsInSubList_Add()">
<h3>testParentStructuralModificationReflectsInSubList_Add</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testParentStructuralModificationReflectsInSubList_Add</span>()</div>
<div class="block">Test di interazione: aggiunta sulla lista padre e "semantica indefinita" della sottolista.
 <p>
 Summary: Questo test verifica il comportamento di una sottolista quando la sua lista padre
 subisce una modifica strutturale (l'aggiunta di un elemento) che **non** è stata effettuata
 tramite le operazioni della sottolista stessa. In particolare, esamina come gli accessi
 tramite <code>get()</code> si riflettano sulla nuova struttura della lista padre, pur mantenendo
 la dimensione interna originale della sottolista.
 <p>
 Test Case Design: Questo test è cruciale per evidenziare la "semantica indefinita" o il comportamento
 "non fail-fast" di implementazioni di `SubList` che non si invalidano automaticamente dopo modifiche
 strutturali esterne alla lista padre. Senza un meccanismo "fail-fast", la `SubList` non viene invalidata,
 ma la sua proprietà `size` interna non si adatta automaticamente a tali modifiche. Di conseguenza,
 il suo comportamento potrebbe diventare inconsistente rispetto alle aspettative di una lista dinamica
 (ad esempio, un elemento potrebbe essere "spinto fuori" dal suo range percepito dalla sottolista).
 Si prevede che i metodi di accesso come <code>get()</code> continuino a funzionare basandosi sulla
 struttura *modificata* della lista padre, ma i controlli sui limiti (es. `IndexOutOfBoundsException`)
 continueranno a usare la dimensione interna non aggiornata della sottolista.
 <p>
 Test Description:
 1) Si verifica la dimensione iniziale della `subList` (attesa: 3).
 2) Viene aggiunto un elemento ("ADDED_BY_PARENT") alla `parentList` ad un indice che cade
    all'interno del range concettuale originale della `subList`.
    - Esempio: se `parentList` era `["zero", "uno", "due", "tre", "quattro", "cinque"]`
    e `subList` rappresentava `parentList[1]` a `parentList[3]` (cioè `["uno", "due", "tre"]`),
    l'aggiunta in `parentList.add(2, "ADDED_BY_PARENT")` modifica la `parentList` in
    `["zero", "uno", "ADDED_BY_PARENT", "due", "tre", "quattro", "cinque"]`.
    Gli elementi originali "due" e "tre" vengono spostati a indici superiori nella `parentList`.
 3) Si verifica che la dimensione interna della `subList` **non sia cambiata** (attesa: 3),
    dato che non c'è un meccanismo "fail-fast" o di aggiornamento automatico della dimensione.
 4) Si verifica che gli elementi acceduti tramite <code>subList.get(relative_index)</code> riflettano
    il nuovo stato della `parentList` a causa dello spostamento degli elementi.
    - `subList.get(0)` dovrebbe ancora restituire "uno" (corrisponde a `parentList.get(1)`).
    - `subList.get(1)` dovrebbe ora restituire "ADDED_BY_PARENT" (corrisponde a `parentList.get(2)`).
    - `subList.get(2)` dovrebbe ora restituire "due" (corrisponde a `parentList.get(3)`).
 5) Si tenta di accedere a un indice (`3`) che originariamente non era valido per la `subList`
    (poiché la sua dimensione interna è ancora 3). Nonostante la `parentList` sia cresciuta,
    ci si aspetta una `IndexOutOfBoundsException` perché il controllo dei limiti della `subList`
    si basa sulla sua dimensione interna non aggiornata. Questo conferma il comportamento "non fail-fast"
    e le "semanticche indefinite".
 <p>
 Preconditions: La `subList` è stata inizializzata come vista di un segmento contiguo della `parentList`.
 `subList` è `["uno", "due", "tre"]` derivata da una `parentList` più ampia: ["zero", "uno", "due", "tre", "quattro", "cinque"]
 <p>
 Postconditions: Viene aggiunto un elemento alla `parentList` all'interno del range originale della `subList`.
 La `subList` continua a fare riferimento alla `parentList` sottostante, ma la sua dimensione interna
 (`size`) non viene aggiornata per riflettere la modifica strutturale della `parentList`.
 <p>
 Expected Result:
 - <code>subList.size()</code> deve rimanere **<code>3</code>**.
 - <code>subList.get(0)</code> deve restituire **"uno"**.
 - <code>subList.get(1)</code> deve restituire **"ADDED_BY_PARENT"**.
 - <code>subList.get(2)</code> deve restituire **"due"**.
 - L'accesso a <code>subList.get(3)</code> (o superiore) deve lanciare una **<code>IndexOutOfBoundsException</code>**,
 poiché l'elemento originale "tre" è stato "spostato" fuori dal range percepito dalla `subList` senza che questa aggiornasse la sua `size`.</div>
</section>
</li>
<li>
<section class="detail" id="testSubListFromSubList()">
<h3>testSubListFromSubList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testSubListFromSubList</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#subList(int,int)"><code>HList.subList(int, int)</code></a> di una <code>SubList</code>.
 <p>
 Summary: Questo test verifica la corretta creazione e il funzionamento di una sottolista
 derivata da una sottolista esistente (una "sub-subList"). Si assicura che le operazioni
 su questa sottolista annidata si riflettano correttamente sulla lista padre originale,
 dimostrando un calcolo cumulativo dell'offset.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire che il meccanismo
 di creazione di sottoliste ricorsive funzioni come previsto. Questo implica che la nuova
 sottolista debba calcolare correttamente il suo offset e la sua dimensione rispetto alla
 sottolista da cui è stata creata, e indirettamente, rispetto alla lista originale.
 È fondamentale che le modifiche non strutturali (come <code>set()</code>) su una sub-subList
 si propaghino correttamente fino alla lista più esterna.
 <p>
 Test Description:
 1) La `subList` iniziale è impostata a `["uno", "due", "tre"]`, che rappresenta gli elementi
    dalla posizione 1 alla 3 (esclusa la 4) della `parentList` (e.g., `parentList[1], parentList[2], parentList[3]`).
 2) Viene creata una `subSubList` chiamando `subList.subList(1, 2)`. Questo dovrebbe estrarre
    l'elemento all'indice relativo 1 della `subList`, che è "due".
 3) Si verifica che la `subSubList` abbia dimensione 1 e che il suo unico elemento sia "due".
 4) Viene modificato l'elemento della `subSubList` tramite <code>subSubList.set(0, "changed by sub-sub")</code>.
 5) Infine, si verifica che questa modifica sia stata correttamente propagata alla `parentList`
    controllando l'elemento alla sua posizione originale (indice 2).
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 La `parentList` contiene questi elementi come parte di un insieme più ampio:
 `["zero", "uno", "due", "tre", "quattro", "cinque"]`.
 <p>
 Postconditions: Viene creata una `subSubList` valida. L'elemento originariamente "due"
 nella `subList` (e `parentList`) viene modificato in "changed by sub-sub".
 La `subSubList` contiene `["changed by sub-sub"]`.
 La `subList` contiene `["uno", "changed by sub-sub", "tre"]`.
 La `parentList` contiene `["zero", "uno", "changed by sub-sub", "tre", "quattro", "cinque"]`.
 <p>
 Expected Result: La `subSubList` deve avere dimensione **<code>1</code>** e contenere **"due"**
 subito dopo la sua creazione. Dopo la modifica tramite <code>set()</code>, l'elemento
 a `parentList.get(2)` (che corrisponde a `subList.get(1)` e `subSubList.get(0)`)
 deve essere **"changed by sub-sub"**.</div>
</section>
</li>
<li>
<section class="detail" id="testSubListFromSubListNegativeFromIndex()">
<h3>testSubListFromSubListNegativeFromIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testSubListFromSubListNegativeFromIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#subList(int,int)"><code>HList.subList(int, int)</code></a> su una <code>SubList</code>.
 <p>
 Summary: Questo test verifica che il metodo <code>subList(int fromIndex, int toIndex)</code>
 lanci una <code>IndexOutOfBoundsException</code> quando il parametro <code>fromIndex</code> è negativo.
 <p>
 Test Case Design: La motivazione principale di questo test è assicurare la conformita' di subList(). Questa specifica impone esplicitamente che venga lanciata una
 <code>IndexOutOfBoundsException</code> se <code>fromIndex</code> è negativo, <code>toIndex</code> è maggiore della dimensione
 della lista, o se <code>fromIndex</code> è maggiore di <code>toIndex</code>. Questo test si concentra
 sul caso specifico di un <code>fromIndex</code> negativo, garantendo una corretta validazione dei limiti.
 <p>
 Test Description:
 1) Si tenta di creare una sottolista dalla `subList` esistente utilizzando il metodo <code>subList(int, int)</code>.
 2) Viene fornito un <code>fromIndex</code> intenzionalmente negativo (pari a `-1`).
 3) Il test si aspetta che, come risultato di questa operazione, venga lanciata una <code>IndexOutOfBoundsException</code>.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene degli elementi ["uno", "due", "tre"].
 <p>
 Postconditions: Nessuna modifica viene apportata alla `subList` o alla `parentList` poiché l'operazione non
 viene completata con successo a causa dell'eccezione.
 <p>
 Expected Result: Ci si aspetta il lancio di una **<code>IndexOutOfBoundsException</code>** quando si chiama <code>subList(-1, 1)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testSubListFromSubListOutOfBoundsToIndex()">
<h3>testSubListFromSubListOutOfBoundsToIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testSubListFromSubListOutOfBoundsToIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#subList(int,int)"><code>HList.subList(int, int)</code></a> su una <code>SubList</code>.
 <p>
 Summary: Questo test verifica che il metodo <code>subList(int fromIndex, int toIndex)</code>
 lanci una <code>IndexOutOfBoundsException</code> quando il parametro <code>toIndex</code> è maggiore
 della dimensione della sottolista su cui viene invocato.
 <p>
 Test Case Design: Questo test è fondamentale per garantire la regolarita' di subList(). La specifica richiede esplicitamente il lancio di una
 <code>IndexOutOfBoundsException</code> se <code>toIndex</code> è maggiore della dimensione della lista.
 Ci assicuriamo che la validazione degli indici funzioni correttamente, in particolare per il limite superiore
 dell'intervallo specificato per la nuova sottolista.
 <p>
 Test Description:
 1) Tentiamo di creare una nuova sottolista dalla `subList` esistente utilizzando il metodo <code>subList(int, int)</code>.
 2) Forniamo un <code>toIndex</code> intenzionalmente fuori limite, pari a <code>4</code>.
    La `subList` ha una dimensione di 3, il che significa che gli indici validi per <code>toIndex</code> vanno da 0 a 3 (escluso).
 3) Il test si aspetta che, come risultato di questa operazione, venga lanciata una **<code>IndexOutOfBoundsException</code>**.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene 3 elementi ["uno", "due", "tre"].
 <p>
 Postconditions: Nessuna modifica viene apportata alla `subList` o alla `parentList` poiché l'operazione non
 viene completata con successo a causa dell'eccezione.
 <p>
 Expected Result: Ci aspettiamo il lancio di una **<code>IndexOutOfBoundsException</code>** quando si chiama `subList(0, 4)`.</div>
</section>
</li>
<li>
<section class="detail" id="testSubListFromSubListFromGreaterThanTo()">
<h3>testSubListFromSubListFromGreaterThanTo</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testSubListFromSubListFromGreaterThanTo</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#subList(int,int)"><code>HList.subList(int, int)</code></a> su una <code>SubList</code>.
 <p>
 Summary: Questo test verifica che il metodo <code>subList(int fromIndex, int toIndex)</code>
 lanci una <code>IndexOutOfBoundsException</code> quando il parametro <code>fromIndex</code> è maggiore
 del parametro <code>toIndex</code>.
 <p>
 Test Case Design: Questo test è cruciale per garantire  il corretto funzionamento di subList(). La specifica richiede esplicitamente il lancio di una
 <code>IndexOutOfBoundsException</code> se <code>fromIndex</code> è maggiore di <code>toIndex</code>.
 Ci assicuriamo che la validazione degli indici funzioni correttamente per prevenire la creazione di
 sottoliste con intervalli non validi o invertiti.
 <p>
 Test Description:
 1) Tentiamo di creare una nuova sottolista dalla `subList` esistente utilizzando il metodo <code>subList(int, int)</code>.
 2) Forniamo un <code>fromIndex</code> (pari a `2`) che è intenzionalmente maggiore del <code>toIndex</code> (pari a `1`).
 3) Il test si aspetta che, come risultato di questa operazione, venga lanciata una **<code>IndexOutOfBoundsException</code>**.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene elementi (ad esempio, `["uno", "due", "tre"]`).
 <p>
 Postconditions: Nessuna modifica viene apportata alla `subList` o alla `parentList` poiché l'operazione non
 viene completata con successo a causa dell'eccezione.
 <p>
 Expected Result: Ci aspettiamo il lancio di una **<code>IndexOutOfBoundsException</code>** quando si chiama `subList(2, 1)`.</div>
</section>
</li>
<li>
<section class="detail" id="testToArray()">
<h3>testToArray</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testToArray</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#toArray()"><code>HCollection.toArray()</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>toArray()</code> su una sottolista
 restituisca correttamente un nuovo array contenente tutti gli elementi della sottolista
 nell'ordine corretto.
 <p>
 Test Case Design: La motivazione principale di questo test è assicurare che la conversione
 della sottolista in un array funzioni correttamente, producendo una "snapshot" degli elementi
 presenti nella vista della sottolista. È fondamentale che l'array risultante contenga
 esattamente gli elementi che la sottolista espone e che la sua dimensione sia accurata.
 <p>
 Test Description:
 1) Viene invocato il metodo <code>toArray()</code> sulla `subList` (che contiene `["uno", "due", "tre"]`).
 2) Si confronta l'array ottenuto con un array atteso (`{"uno", "due", "tre"}`) utilizzando
 `assertArrayEquals` per verificare che gli elementi e il loro ordine corrispondano.
 3) Si verifica esplicitamente che la lunghezza dell'array risultante sia pari alla dimensione
 della sottolista (attesa: 3).
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 <p>
 Postconditions: Un nuovo array di `Object` è stato creato e restituito. Nessuna modifica
 viene apportata alla `subList` o alla `parentList`.
 <p>
 Expected Result: L'array restituito da <code>toArray()</code> deve avere una lunghezza di **3**
 e i suoi elementi devono essere **`{"uno", "due", "tre"}`**, nell'ordine specificato.</div>
</section>
</li>
<li>
<section class="detail" id="testToArrayWithSufficientlyLargeArray()">
<h3>testToArrayWithSufficientlyLargeArray</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testToArrayWithSufficientlyLargeArray</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#toArray(java.lang.Object%5B%5D)"><code>HCollection.toArray(Object[])</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>toArray(Object[] a)</code> su una sottolista
 riempia correttamente l'array fornito con gli elementi della sottolista quando l'array
 in input è sufficientemente grande da contenerli tutti. Inoltre, assicura che l'elemento
 immediatamente successivo all'ultimo elemento della sottolista nell'array fornito sia impostato a <code>null</code>.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire che l'implementazione
 del metodo <code>toArray(Object[] a)</code> nella sottolista rispetti la specifica del metodo. Prevede il riutilizzo dell'array fornito
 se la sua dimensione è adeguata e l'impostazione a <code>null</code> dell'elemento successivo se ve ne sono.
 Questo assicura l'efficienza (evitando la creazione di un nuovo array) e la correttezza del riempimento.
 <p>
 Test Description:
 1) Viene inizializzato un array di `String` (`arr`) con una dimensione maggiore rispetto al numero
    di elementi presenti nella `subList` (ad esempio, 5 elementi per una `subList` di 3 elementi).
 2) Si invoca il metodo <code>toArray(Object[] a)</code> sulla `subList`, passando `arr` come argomento.
 3) Si verifica, tramite <code>assertSame()</code>, che il metodo restituisca una referenza allo stesso array
    che è stato passato come input, confermando il riutilizzo.
 4) Si assicura che i primi elementi dell'array (`arr[0]`, `arr[1]`, `arr[2]`) corrispondano
    agli elementi della `subList` (`"uno"`, `"due"`, `"tre"`).
 5) Si verifica che l'elemento immediatamente successivo all'ultimo elemento della sottolista nell'array
    (`arr[3]`) sia impostato a <code>null</code>, come da specifica. Anche gli elementi successivi (`arr[4]`)
    devono rimanere <code>null</code> se lo erano già.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 Viene fornito un array di tipo compatibile e di dimensione sufficiente (ad esempio, 5 per 3 elementi).
 <p>
 Postconditions: L'array fornito in input viene modificato: i suoi primi elementi contengono
 gli elementi della sottolista nell'ordine corretto, e l'elemento immediatamente successivo
 all'ultimo elemento della sottolista è impostato a <code>null</code> (se l'array era abbastanza grande).
 Nessuna modifica strutturale viene apportata alla `subList` o alla `parentList`.
 <p>
 Expected Result: Il metodo deve restituire lo **stesso array** passato come argomento.
 L'array deve contenere `["uno", "due", "tre", null, null]` (o `null` solo all'indice 3 se fosse un array di 4 elementi),
 e la sua lunghezza deve rimanere quella originale fornita.</div>
</section>
</li>
<li>
<section class="detail" id="testToArrayWithTooSmallArray()">
<h3>testToArrayWithTooSmallArray</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testToArrayWithTooSmallArray</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#toArray(java.lang.Object%5B%5D)"><code>HCollection.toArray(Object[])</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>toArray(Object[] a)</code> su una sottolista
 crei e restituisca un **nuovo array** della dimensione corretta, contenente tutti gli elementi
 della sottolista, quando l'array fornito in input è troppo piccolo per contenerli.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire che l'implementazione
 del metodo <code>toArray(Object[] a)</code> rispetti pienamente la specifica. Questa specifica prevede che, se l'array fornito
 non è sufficientemente grande, debba essere creato un nuovo array dello stesso tipo (runtime type)
 della lista e riempito con i suoi elementi. Questo assicura che l'operazione funzioni sempre,
 indipendentemente dalla dimensione dell'array iniziale.
 <p>
 Test Description:
 1) Viene inizializzato un array di `String` (`arr`) con una dimensione intenzionalmente
    più piccola rispetto al numero di elementi presenti nella `subList` (ad esempio, 2 elementi per una `subList` di 3).
 2) Si invoca il metodo <code>toArray(Object[] a)</code> sulla `subList`, passando `arr` come argomento.
 3) Si verifica, tramite <code>assertNotSame()</code>, che il metodo **non** restituisca una referenza
    allo stesso array che è stato passato come input, confermando la creazione di un nuovo array.
 4) Si assicura che la lunghezza del nuovo array risultante sia esattamente pari alla dimensione
    della sottolista (attesa: 3).
 5) Si verifica che tutti gli elementi dell'array restituito (`result[0]`, `result[1]`, `result[2]`)
    corrispondano agli elementi della `subList` (`"uno"`, `"due"`, `"tre"`), nell'ordine corretto.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 Viene fornito un array di tipo compatibile ma di dimensione insufficiente (ad esempio, 2 per 3 elementi).
 <p>
 Postconditions: Viene creato e restituito un nuovo array di `Object` (o del tipo runtime corretto).
 L'array originale passato come input rimane invariato. Nessuna modifica strutturale viene
 apportata alla `subList` o alla `parentList`.
 <p>
 Expected Result: Il metodo deve restituire un **nuovo array** (non lo stesso array passato come argomento).
 Il nuovo array deve avere una lunghezza di **3** e il suo contenuto deve essere **`{"uno", "due", "tre"}`**.</div>
</section>
</li>
<li>
<section class="detail" id="testToArrayNullArray()">
<h3>testToArrayNullArray</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testToArrayNullArray</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#toArray(java.lang.Object%5B%5D)"><code>HCollection.toArray(Object[])</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>toArray(Object[] a)</code> lanci
 una <code>NullPointerException</code> quando l'array fornito come argomento è <code>null</code>.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire la piena conformita' del metodo. Questa specifica impone esplicitamente il lancio di una
 <code>NullPointerException</code> nel caso in cui l'argomento `a` (l'array in cui memorizzare gli elementi)
 sia un riferimento <code>null</code>. Questo test convalida il comportamento atteso del metodo di fronte a un input non valido.
 <p>
 Test Description:
 1) Tentiamo di convertire la `subList` in un array utilizzando il metodo <code>toArray(Object[] a)</code>.
 2) Forniamo intenzionalmente un riferimento <code>null</code> come argomento per l'array.
 3) Il test si aspetta che, come risultato di questa operazione, venga lanciata una **<code>NullPointerException</code>**.
 <p>
 Preconditions: La subList è stata inizializzata e contiene elementi ["uno", "due", "tre"].
 L'argomento passato a <code>toArray()</code> è <code>null</code>.
 <p>
 Postconditions: Nessuna modifica viene apportata alla `subList` o alla `parentList` poiché l'operazione non
 viene completata con successo a causa dell'eccezione.
 <p>
 Expected Result: Ci aspettiamo il lancio di una **<code>NullPointerException</code>** quando si chiama `toArray(null)`.</div>
</section>
</li>
<li>
<section class="detail" id="testIterator()">
<h3>testIterator</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testIterator</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HCollection.html#iterator()"><code>HCollection.iterator()</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>iterator()</code> su una sottolista
 restituisca un iteratore correttamente funzionante, che permetta di percorrere tutti
 gli elementi della sottolista nell'ordine di inserimento.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire che l'iteratore
 fornito dalla sottolista sia una vista accurata e navigabile degli elementi che essa gestisce.
 È fondamentale che l'iteratore esponga esattamente gli elementi nel range definito dalla
 sottolista e che segua la logica standard degli iteratori (<code>hasNext()</code> e <code>next()</code>).
 <p>
 Test Description:
 1) Viene ottenuto un iteratore per la `subList` tramite la chiamata a <code>subList.iterator()</code>.
 2) Si utilizzano i metodi <code>hasNext()</code> e <code>next()</code> dell'iteratore per scorrere
 attraverso tutti gli elementi previsti nella `subList` (`"uno"`, `"due"`, `"tre"`).
 3) Ad ogni passo, si verifica che <code>hasNext()</code> restituisca <code>true</code> prima di un elemento atteso
 e che <code>next()</code> restituisca l'elemento corretto.
 4) Dopo aver recuperato l'ultimo elemento, si verifica che <code>hasNext()</code> restituisca <code>false</code>,
 confermando che l'iterazione è terminata e non ci sono più elementi da percorrere.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene gli elementi ["uno", "due", "tre"].
 <p>
 Postconditions: L'iteratore ha percorso tutti gli elementi della `subList` senza errori.
 Nessuna modifica strutturale o di contenuto viene apportata alla `subList` o alla `parentList`
 durante l'iterazione.
 <p>
 Expected Result: L'iteratore deve restituire gli elementi nell'ordine corretto: **"uno"**, **"due"**, e **"tre"**.
 Le chiamate a <code>hasNext()</code> e <code>next()</code> devono comportarsi come previsto per un iteratore completo.</div>
</section>
</li>
<li>
<section class="detail" id="testListIterator()">
<h3>testListIterator</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testListIterator</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator()"><code>HList.listIterator()</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>listIterator()</code> su una sottolista
 restituisca un **List Iterator** correttamente funzionante, capace di percorrere tutti
 gli elementi della sottolista nell'ordine di inserimento.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire che il List Iterator
 fornito dalla sottolista sia una vista accurata e navigabile bidirezionalmente degli elementi
 che essa gestisce. È fondamentale che il List Iterator esponga esattamente gli elementi nel range
 definito dalla sottolista e che segua la logica standard dei List Iterator (<code>hasNext()</code>,
 <code>next()</code>, <code>hasPrevious()</code>, <code>previous()</code>, ecc.). Questo test si concentra
 sul percorso in avanti.
 <p>
 Test Description:
 1) Viene ottenuto un List Iterator per la `subList` tramite la chiamata a <code>subList.listIterator()</code>.
 2) Si utilizzano i metodi <code>hasNext()</code> e <code>next()</code> del List Iterator per scorrere
 attraverso tutti gli elementi previsti nella `subList` (`"uno"`, `"due"`, `"tre"`).
 3) Ad ogni passo, si verifica che <code>hasNext()</code> restituisca <code>true</code> prima di un elemento atteso
 e che <code>next()</code> restituisca l'elemento corretto.
 4) Dopo aver recuperato l'ultimo elemento, si verifica che <code>hasNext()</code> restituisca <code>false</code>,
 confermando che l'iterazione in avanti è terminata e non ci sono più elementi da percorrere.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 <p>
 Postconditions: Il List Iterator ha percorso tutti gli elementi della `subList` senza errori.
 Nessuna modifica strutturale o di contenuto viene apportata alla `subList` o alla `parentList`
 durante l'iterazione.
 <p>
 Expected Result: Il List Iterator deve restituire gli elementi nell'ordine corretto: **"uno"**, **"due"**, e **"tre"**.
 Le chiamate a <code>hasNext()</code> e <code>next()</code> devono comportarsi come previsto per un List Iterator.</div>
</section>
</li>
<li>
<section class="detail" id="testListIteratorFromIndexStart()">
<h3>testListIteratorFromIndexStart</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testListIteratorFromIndexStart</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>listIterator(int index)</code> su una sottolista
 restituisca un **List Iterator** correttamente inizializzato che comincia la sua traversata
 (o si posiziona) all'indice specificato, permettendo di accedere correttamente all'elemento successivo.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire che il List Iterator possa essere
 posizionato correttamente a un indice arbitrario specificato al momento della sua creazione.
 In questo caso specifico, verifichiamo il posizionamento all'inizio della sottolista (indice 0),
 assicurandoci che il primo elemento restituito da <code>next()</code> sia quello atteso per tale posizione.
 <p>
 Test Description:
 1) Viene ottenuto un List Iterator per la `subList` tramite la chiamata a <code>subList.listIterator(0)</code>,
    chiedendo che l'iteratore si posizioni all'inizio della sottolista.
 2) Si verifica che <code>hasNext()</code> restituisca <code>true</code>, indicando che ci sono elementi da percorrere.
 3) Si invoca <code>next()</code> e si assicura che restituisca `"uno"`, che è il primo elemento della `subList`.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 <p>
 Postconditions: Il List Iterator è stato creato e posizionato all'indice 0.
 Nessuna modifica strutturale o di contenuto viene apportata alla `subList` o alla `parentList`.
 <p>
 Expected Result: La chiamata a <code>it.hasNext()</code> deve restituire **<code>true</code>**, e <code>it.next()</code>
 deve restituire **"uno"**.</div>
</section>
</li>
<li>
<section class="detail" id="testListIteratorFromIndexMid()">
<h3>testListIteratorFromIndexMid</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testListIteratorFromIndexMid</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>listIterator(int index)</code> su una sottolista
 restituisca un **List Iterator** correttamente inizializzato e posizionato a un indice intermedio specificato,
 consentendo di accedere agli elementi successivi a partire da quel punto.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire che il List Iterator sia in grado di
 essere posizionato accuratamente a un indice arbitrario all'interno della sottolista al momento della sua creazione.
 In questo scenario, ci concentriamo su un posizionamento intermedio (indice 1), verificando che il primo
 elemento restituito da <code>next()</code> sia quello atteso e che la successiva iterazione proceda correttamente.
 <p>
 Test Description:
 1) Viene ottenuto un List Iterator per la `subList` tramite la chiamata a <code>subList.listIterator(1)</code>,
    richiedendo che l'iteratore si posizioni all'indice 1 della sottolista (cioè prima dell'elemento "due").
 2) Si verifica che <code>hasNext()</code> restituisca <code>true</code>, indicando che ci sono elementi da percorrere.
 3) Si invoca <code>next()</code> e si assicura che restituisca **"due"**, che è l'elemento atteso all'indice 1 della `subList`.
 4) Si procede con l'iterazione, verificando che il successivo <code>hasNext()</code> sia <code>true</code>
    e che <code>next()</code> restituisca **"tre"**.
 5) Infine, si verifica che <code>hasNext()</code> restituisca <code>false</code>, confermando che l'iterazione è terminata.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 <p>
 Postconditions: Il List Iterator è stato creato e posizionato all'indice 1.
 Nessuna modifica strutturale o di contenuto viene apportata alla `subList` o alla `parentList` durante l'iterazione.
 <p>
 Expected Result: Le chiamate a <code>hasNext()</code> e <code>next()</code> devono comportarsi come previsto
 partendo dall'indice 1, restituendo prima **"due"** e poi **"tre"**, e poi indicando la fine degli elementi.</div>
</section>
</li>
<li>
<section class="detail" id="testListIteratorFromIndexEnd()">
<h3>testListIteratorFromIndexEnd</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testListIteratorFromIndexEnd</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>listIterator(int index)</code> su una sottolista
 restituisca un **List Iterator** correttamente inizializzato e posizionato alla fine della lista.
 Tale posizionamento è tipico per operazioni di aggiunta o per iniziare una traversata a ritroso.
 <p>
 Test Case Design: La motivazione principale di questo test è garantire che il List Iterator possa essere
 posizionato correttamente all'indice equivalente alla dimensione della lista. Questo punto di posizionamento
 è standard nella libreria Collections di Java e indica che l'iteratore si trova "dopo" l'ultimo elemento,
 pronto per operazioni come <code>add()</code> o <code>previous()</code>.
 <p>
 Test Description:
 1) Viene ottenuto un List Iterator per la `subList` tramite la chiamata a <code>subList.listIterator(subList.size())</code>,
 richiedendo che l'iteratore si posizioni alla fine della sottolista.
 2) Si verifica che <code>hasNext()</code> restituisca **<code>false</code>**, confermando che, essendo alla fine,
 non ci sono più elementi da percorrere in avanti.
 3) Si assicura che <code>nextIndex()</code> restituisca un valore pari alla dimensione della `subList`,
 che è l'indice atteso quando l'iteratore è posizionato alla fine.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene gli elementi `["uno", "due", "tre"]`.
 <p>
 Postconditions: Il List Iterator è stato creato e posizionato correttamente alla fine della `subList`.
 Nessuna modifica strutturale o di contenuto viene apportata alla `subList` o alla `parentList`.
 <p>
 Expected Result: La chiamata a <code>it.hasNext()</code> deve restituire **<code>false</code>**.
 La chiamata a <code>it.nextIndex()</code> deve restituire un valore pari alla **dimensione corrente della `subList`**.</div>
</section>
</li>
<li>
<section class="detail" id="testListIteratorNegativeIndex()">
<h3>testListIteratorNegativeIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testListIteratorNegativeIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>listIterator(int index)</code> lanci
 una **<code>IndexOutOfBoundsException</code>** quando l'indice specificato per l'inizializzazione
 del List Iterator è negativo.
 <p>
 Test Case Design: Questo test è fondamentale per garantire la correttezza del metodo. La specifica impone esplicitamente il lancio di una
 <code>IndexOutOfBoundsException</code> se l'indice non è compreso tra 0 (incluso) e <code>size()</code> (incluso).
 Questo caso specifico si concentra sulla violazione del limite inferiore dell'indice.
 <p>
 Test Description:
 1) Tentiamo di ottenere un List Iterator per la `subList` utilizzando il metodo <code>listIterator(int)</code>.
 2) Forniamo un indice intenzionalmente negativo (pari a `-1`).
 3) Il test si aspetta che, come risultato di questa operazione, venga lanciata una **<code>IndexOutOfBoundsException</code>**.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene elementi (ad esempio, `["uno", "due", "tre"]`).
 <p>
 Postconditions: Nessuna modifica viene apportata alla `subList` o alla `parentList` poiché l'operazione non
 viene completata con successo a causa dell'eccezione.
 <p>
 Expected Result: Ci aspettiamo il lancio di una **<code>IndexOutOfBoundsException</code>** quando si chiama <code>listIterator(-1)</code>.</div>
</section>
</li>
<li>
<section class="detail" id="testListIteratorOutOfBoundsIndex()">
<h3>testListIteratorOutOfBoundsIndex</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">testListIteratorOutOfBoundsIndex</span>()</div>
<div class="block">Test del metodo <a href="../myAdapter/HList.html#listIterator(int)"><code>HList.listIterator(int)</code></a>.
 <p>
 Summary: Questo test verifica che il metodo <code>listIterator(int index)</code> lanci
 una **<code>IndexOutOfBoundsException</code>** quando l'indice specificato per l'inizializzazione
 del List Iterator è maggiore della dimensione della sottolista.
 <p>
 Test Case Design: Questo test è cruciale per garantire la specifica: essa impone esplicitamente il lancio di una
 <code>IndexOutOfBoundsException</code> se l'indice non è compreso tra 0 (incluso) e <code>size()</code> (incluso).
 Questo caso specifico si concentra sulla violazione del limite superiore dell'indice, assicurando
 che non sia possibile creare un iteratore posizionato al di fuori dei confini validi della lista.
 <p>
 Test Description:
 1) Tentiamo di ottenere un List Iterator per la `subList` utilizzando il metodo <code>listIterator(int)</code>.
 2) Forniamo un indice intenzionalmente fuori limite, calcolato come `subList.size() + 1`.
 Ad esempio, se la `subList` ha dimensione 3, l'indice sarà 4.
 3) Il test si aspetta che, come risultato di questa operazione, venga lanciata una **<code>IndexOutOfBoundsException</code>**.
 <p>
 Preconditions: La `subList` è stata inizializzata e contiene 3 elementi (ad esempio, `["uno", "due", "tre"]`).
 <p>
 Postconditions: Nessuna modifica viene apportata alla `subList` o alla `parentList`, poiché l'operazione non
 viene completata con successo a causa dell'eccezione.
 <p>
 Expected Result: Ci aspettiamo il lancio di una **<code>IndexOutOfBoundsException</code>** quando si chiama <code>listIterator(subList.size() + 1)</code>.</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
